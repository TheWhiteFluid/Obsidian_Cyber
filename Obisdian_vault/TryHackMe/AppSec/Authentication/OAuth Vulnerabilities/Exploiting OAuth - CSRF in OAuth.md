The **state** parameter in the OAuth 2.0 framework protects against CSRF attacks, which occur when an attacker tricks a user into executing unwanted actions on a web application where they are currently authenticated. In the context of OAuth, CSRF attacks can lead to unauthorized access to sensitive resources by hijacking the OAuth flow. The state parameter helps mitigate this risk by maintaining the integrity of the authorization process.

## Vulnerability of Weak or Missing State Parameter
The state parameter is an arbitrary string that the client application includes in the authorization request. When the authorization server redirects the user back to the client application with the authorization code, it also includes the state parameter. The client application then verifies that the state parameter in the response matches the one it initially sent. This validation ensures that the response is not a result of a CSRF attack but a legitimate continuation of the OAuth flow.

For instance, consider an OAuth implementation where the state parameter is either **missing** or **predictable** (e.g., a static value like "state" or a simple sequential number). An attacker can initiate an OAuth flow and provide their malicious redirect URI. After the user authenticates and authorizes the application, the authorization server redirects the authorization code to the attacker's controlled URI, as specified by the weak or absent state parameter.

## Example
In this exercise, we will explore how the absence of the state parameter in the OAuth authorization process can lead to CSRF attacks. You will need to use the AttackBox to understand the attack from both the attacker's and the victim's perspectives. We will be using the app `mycontacts.thm:8080` app that allows you to sync contacts from any platform.

### Attacker Perspective
First, visit the website in the AttackBox using the link `http://mycontacts.thm:8080/csrf/index.php` with the credentials `attacker:attacker`. Once you log in, you will see a page that allows you to sync contacts to `CoffeeShopApp`. Once the accounts are synced, all the current accounts from the client app are transferred to the `CoffeeShopApp` account.
	![](Pasted%20image%2020241201232233.png)
If you click on the "**Sync Contacts**" button, you will be redirected to an OAuth authorization server with the  URL `http://coffee.thm:8000/o/authorize/?response_type=code&client_id=kwoy5pKgHOn0bJPNYuPdUL2du8aboMX1n9h9C0PN&redirect_uri=http%3A%2F%2Fcoffee.thm%2Fcsrf%2Fcallbackcsrf.php`.

As a pentester, you will notice that the authorization URL is missing the state parameter, suggesting we can use the same request for a CSRF attack. Here, you don't need to sync your actual account. Let's exploit this vulnerability to attach the **attacker's third-party account to a victim account**.

### Exploiting the Vulnerability
Without the `state` parameter, the authorization process is vulnerable to CSRF. The attacker can exploit this vulnerability by obtaining the victim's authorization code and sending it to the attacker. The authorization server won't have any way to determine whether the authorization code belongs to the **attacker** or the **victim** or whether the request is coming from the attacker or the victim.

To prepare the payload, the attacker must get his authorization code. This can be done by intercepting the authorization process using a tool like Burp Suite or any other network interception tool.
	![](Pasted%20image%2020241201235458.png)
```
http://coffee.thm:8000/o/authorize/?response_type=code&client_id=kwoy5pKgHOn0bJPNYuPdUL2du8aboMX1n9h9C0PN&redirect_uri=http://coffee.thm:8000/oauthdemo/callbackforcsrf/
```

![](Pasted%20image%2020241202000931.png)

Payload:
```python
def oauth_logincsrf(request):
    app = Application.objects.get(name="ContactApp")
    redirect_uri = request.POST.get("redirect_uri", "http://coffee.thm/csrf/callbackcsrf.php") 
    
    authorization_url = (
        f"http://coffee.thm:8000/o/authorize/?client_id={app.client_id}&response_type=code&redirect_uri={redirect_uri}"
    )
    return redirect(authorization_url)

def oauth_callbackflagcsrf(request):
    code = request.GET.get("code")
    
    if not code:
        return JsonResponse({'error': 'missing_code', 'details': 'Missing code parameter.'}, status=400) 

    if code:
        return JsonResponse({'code': code, 'Payload': 'http://coffee.thm/csrf/callbackcsrf.php?code='+code}, status=400)
        ```

Accessing the above authorization code link intercepted by burp will generate each time a different oauth code as per example:![](Pasted%20image%2020241202000836.png)![](Pasted%20image%2020241202000003.png)
The above authorization code would enable anyone to get an access token against it. The URL parameter in the response is the actual payload that we need to send to the victim. Copy the `Payload` value, which we will use while launching the attack.

The attacker needs their **authorization code** as a stepping stone to obtaining an **access token**
1. **Authorization Code as a Credential**:  
    In the OAuth flow, the **authorization code** acts as a temporary credential that allows the client (attacker) to request an access token from the authorization server. Without this code, the attacker cannot proceed to the next stage of acquiring the token.
    
2. **Token Exchange Process**:  
    Once the attacker obtains the authorization code, they can exchange it for an **access token**, which grants access to protected resources. This token is what ultimately allows unauthorized access, enabling the attacker to perform malicious actions.
    
3. **Payload Construction**:  
    The payload URL generated (`http://coffee.thm/csrf/callbackcsrf.php?code=`) includes the attacker’s authorization code. This crafted URL is sent to the victim to trick them into authenticating, allowing the attacker to capture their session or escalate privileges by abusing the token exchange.
    
4. **Exploitation Step**:  
    The attacker’s authorization code is embedded in the payload that gets redirected to the OAuth endpoint. When the victim interacts with this, the attacker can intercept or manipulate the process to gain unauthorized access.
    
In short, the **authorization code** is essential because it allows the attacker to initiate the token exchange process and set up the attack payload effectively.

### Launching the Attack
- Once the attacker has obtained the authorization code, he can prepare the CSRF payload. Suppose the attacker sends an email to the victim with a link like `http://bistro.thm:8080/csrf/callbackcsrf.php?code=xxxx`.  
    
- After receiving the email, if the victim clicks on the link or executes it in his browser (where `xxx` is the attacker's authorization code), the attacker's `CoffeeShopApp` OAuth account will be linked to the victim's account. This effectively transfers all the contacts from the victim's account to the attacker's.

### Victim Perspective
- In the attached VM, to practically test it as a victim, log into the client app at [http://bistro.thm:8080/csrf/](http://bistro.thm:8080/csrf/) with the credentials `victim:victim`. For the sake of exercise, since the authorization code is unique, execute the attacker exploit (**link: http://bistro.thm:8080/csrf/callbackcsrf.php?code=xxxx**) by pasting it directly into the browser.
- As discussed above, the exact link sent to the victim is the **URL** parameter received during the **Preparing the Payload** process. Once executed, the code will make a call to get the access token and send contacts/messages to the attacker's account.