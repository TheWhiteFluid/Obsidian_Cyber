So far, the attack vectors we have looked at depend on the backend server to reuse a single HTTP connection to serve all users. In certain proxy implementations, each user will get its own backend connection to separate their request from others. Whenever this happens, an attacker won't be able to influence the requests of other users. At first sight, it would appear that we can't do much if confined to our own connection, but we can still smuggle requests through the frontend proxy and achieve some results. Since we can only smuggle requests to our connection, this scenario is often called request tunnelling.
	![](Pasted%20image%2020250214104223.png)

In the following three tasks, we will use an old version of HAProxy, vulnerable to [CVE-2019-19330](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-19330) as our frontend proxy. This version allows request smuggling by using the CRLF injection technique. The vulnerable backend application will be accessible through the proxy at [https://10.10.111.74:8100](https://10.10.111.74:8100/).

## Leaking Internal Headers
The simplest way to abuse request tunnelling is to get some information on how the backend requests look. In some scenarios, the frontend proxies may add headers to the requests before sending them to the backend. If we want to smuggle a specific request to the backend, we may need to add such headers for the request to go through.

To leak such headers, we can abuse any functionality in the backend application that reflects a parameter from the request into the response. In our case, the application reflects whatever data is sent to `/hello` through the `q` POST parameter. Here's how the request would look like:
	![](Pasted%20image%2020250214105041.png)

Notice the existence of a `content-length` header despite being ignored by HTTP/2. Most browsers will add this header to all HTTP/2 requests so that the backend will still receive a valid `Content-Length` header if an HTTP downgrade occurs. In the backend, the request would be converted into HTTP/1.1. This particular proxy will insert the `Host:` header after the headers sent by the client (right after content-length). If needed, the proxy could also add any additional headers (represented as X-Internal in the image). The final backend request would look like this:
	![](Pasted%20image%2020250214105209.png)
		![](Pasted%20image%2020250214105220.png)

We will take advantage of the vulnerability in HAProxy that allows us to inject CRLFs via headers to leak the backend headers successfully. We will add a custom Foo header and send our attack payload through it. This is how our request would look:
	![](Pasted%20image%2020250214105321.png)

- This will be a normal request for the frontend since HTTP/2 doesn't care about binary information in its headers.
- The `Content-Length: 0` header injected through the Foo header will make the backend think the first POST request has no body. Whatever comes after the headers will be interpreted as a second request.
- Since the `Host` header and any other internal headers are inserted by the proxy after `Foo`, the first POST request will have no `Host` header unless we provide one. This is why we injected a `Host` header for the first request. This is required, as the HTTP/1.1 specification requires a `Host` header for each request.
- The second POST request will trigger a search on the website. Notice how the internal headers are now part of the `q` parameter in the body of the request. This will cause the website to reflect the headers back to us.
- The second POST request we have injected has a `Content-Length: 300`. This number is just an initial guess of how much space we will require for the Internal headers. You will need to play a bit with it until you get the right answer. If it's set too high, the connection will hang as the backend waits for that many bytes to be transferred. If you set it too low, you may only get a part of the internal headers.

Now let's try sending this using Burp. First, capture the request that is sent by the website when performing a search. You should be able to identify a POST request being sent to `/hello`. Right-click the request and send it to Repeater:
	![](Pasted%20image%2020250214111137.png)

**Note:** 
	Be sure to send an HTTP/2 request to repeater. Under certain circumstances, your browser may send an HTTP/1.1 request the first time you request a resource. In that case, simply refresh the website, and it should send an HTTP/2 request the second time.

Once our request is in the Repeater tab, we'll do two modifications to it:
1. Delete the body content.
2. Set the `Content-Length` header to 0. We do this for the same reason as before. We want the first request to be a POST with no body. Remember we will need to disable the `Update Content-Length` setting on Repeater to avoid Burp overwriting our custom value.
	![](Pasted%20image%2020250214111220.png)

Let's add our custom `Foo` header with an initial content of bar. Notice that Burp allows us to edit the HTTP/2 request as if it were an HTTP/1 request. This is somewhat convenient as long as you don't need to insert binary characters in the request. Since we will be adding CRLFs to the request, editing the request as text won't be possible. Instead, we will use the Inspector pane at the right, since it allows for a much more precise editing of the request:
	![](Pasted%20image%2020250214111300.png)

Let's click the arrow beside the `foo` header in the Inspector and edit it to our desired value. Note that to insert a CRLF in the header value, you will need to press `SHIFT + ENTER`. The final result should look like this:
	![](Pasted%20image%2020250214111309.png)

Once you press the `Apply changes` button, the Request pane will go blank and show you a message indicating the request is "**kettled**". This means that there's no way to represent the request in pure text anymore because of the special characters it contains (CRLFs in our case). From now on, all modifications to the request shall be done through the Inspector only.

When the request is ready, you can press the `Send` button as usual to send it. Remember that our HTTP/2 request will be split into two backend requests, so the first time you send it, you will only obtain the response of the first request, which is empty. To get the value of the hidden internal headers, you will need to send the same request twice in quick succession. If all goes well, the website should reflect the internal headers to you on the second request:
		![](Pasted%20image%2020250214111323.png)


## Bypassing Frontend Restrictions
