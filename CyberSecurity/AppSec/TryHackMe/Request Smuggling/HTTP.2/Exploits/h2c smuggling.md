
## HTTP Version Negotiation
Web servers can offer the client many HTTP protocol versions in a single port. This is useful since you can't guarantee that users will have an HTTP/2-compliant browser. In this way, the server can offer the client both HTTP/1.1 and HTTP/2, and the client can select the version they want to use. This process is known as negotiation and is handled entirely by your browser. 

The original HTTP/2 specification defined two ways to negotiate HTTP/2, depending on whether the communications were encrypted or not. The two methods used the following protocol identifiers:
- **h2:** Protocol used when running HTTP/2 over a TLS-encrypted channel. It relies on the Application Layer Protocol Negotiation (ALPN) mechanism of TLS to offer HTTP/2.
- **h2c:** HTTP/2 over cleartext channels. This would be used when encryption is not available. Since ALPN is a feature of TLS, you can't use it in cleartext channels. In this case, the client sends an initial HTTP/1.1 request with a couple of added headers to request an upgrade to HTTP/2. If the server acknowledges the additional headers, the connection is upgraded to HTTP/2.

The h2 protocol is the usual way to implement HTTP/2 since it is considered more secure. In fact, the h2c specification is now regarded as obsolete to the point where most modern browsers don't even support it. Many server implementations, however, still support h2c for compatibility reasons, enabling a different way to smuggle requests.

### h2c Upgrades
When negotiating a cleartext HTTP/2 connection, the client will send a regular HTTP/1.1 request with the `Upgrade: h2c` header to let the server know it supports h2c. The request must also include an additional `HTTP2-Settings` header with some negotiation parameters that we won't discuss in detail. A compliant server will accept the upgrade with a `101 Switching Protocols` response. From that point, the connection switches to HTTP/2.
	![](Pasted%20image%2020250214133219.png)


## Tunneling Requests via h2c Smuggling
When an HTTP/1.1 connection upgrade is attempted via some reverse proxies, they will directly forward the upgrade headers to the backend server instead of handling it themselves. The backend server will perform the upgrade and manage communications in the new protocol afterwards. The proxy will tunnel any further communications between client and server but won't check their contents anymore, since it assumes the protocol changed to something other than HTTP.
	![](Pasted%20image%2020250214133330.png)

Since connections in HTTP/2 are persistent by default, we should be able to send other HTTP/2 requests, which will now go directly to the backend server through the HTTP/2 tunnel. This technique is known as **h2c smuggling**.

**Note1:**
	For h2c smuggling to work, the proxy must forward the h2c upgrade to the backend. Some proxies are aware of h2c and could try to handle the connection upgrade themselves. In those cases, we would end up with a frontend connection upgraded to HTTP/2 instead of a direct tunnel to the backend, which wouldn't be of much use.

When facing an h2c-aware proxy, there's still a chance to get h2c smuggling to work under a specific scenario. If the frontend proxy supports HTTP/1.1 over TLS, we can try performing the h2c upgrade over the TLS channel. This is an unusual request, since h2c is defined to work under cleartext channels only. The proxy may just forward the upgrade headers instead of handling the upgrade directly, as it wouldn't make sense to have h2c over an encrypted channel according to the specification.

**Note2:**
	h2c smuggling only allows for request tunnelling. Poisoning other users' connections won't be possible. But as we have already shown, this could still be abused to bypass restrictions on the frontend or even attempt cache poisoning.


## Bypassing Frontend Restrictions With h2csmuggler
For this scenario, you will be attacking the application exposed in [https://10.10.111.74:8200](https://10.10.111.74:8200/) The application is served through a HAProxy instance with default configurations. The application exposes two endpoints:

1. The `/` endpoint contains a simple website and is allowed through the proxy.
2. The `/private` endpoint is not allowed through the proxy. You can try accessing it at [https://10.10.111.74:8200/private](https://10.10.111.74:8200/private) and you should get a `403 Forbidden` response.

Our objective will be to use h2c smuggling to get the contents of `/private` through the proxy. We will use the [h2csmuggler](https://github.com/BishopFox/h2csmuggler) tool provided by BishopFox to do so. The tool will perform the full attack for us since doing it manually would be somewhat complicated.

The following command would first attempt an h2c upgrade while requesting `/`. Since that resource is allowed by the proxy, the connection will upgrade successfully to HTTP/2. The HTTP/2 tunnel would then be used to request `/private`, bypassing the frontend restrictions:
```shell
python3 h2csmuggler.py -x https://10.10.111.74:8200/ https://10.10.111.74:8200/private
```

**Note:**
	You may need to run the command a couple of times if it fails.