To smuggle requests through a vulnerable proxy, we can create a malformed request such that the proxy thinks a WebSocket upgrade is performed, but the backend server doesn't really upgrade the connection. This will force the proxy into establishing a tunnel between client and server that will go unchecked since it assumes it is now a WebSocket connection, but the backend will still expect HTTP traffic.

One way to force this is to send an upgrade request with an invalid `Sec-Websocket-Version` header. This header is used to specify the version of the WebSocket protocol to use and will normally take the value of `13` in most current WebSocket implementations. If the server supports the requested version, it should issue a `101 Switching Protocols` response and upgrade the connection.

But we aren't interested in upgrading the connection. If we send an unsupported value for the `Sec-Websocket-Version` header, the server will send a `426 Upgrade Required` response to indicate the upgrade was unsuccessful:
	![](Pasted%20image%2020250215032641.png)

Some proxies may assume that the upgrade is always completed, regardless of the server response. This can be abused to smuggle HTTP requests once again by performing the following steps:
1. The client sends a WebSocket upgrade request with an **invalid** version number.
2. The proxy forwards the request to the backend server.
3. The backend server responds with `426 Upgrade Required`. The connection doesn't upgrade, so the backend remains using HTTP instead of switching to a WebSocket connection.
4. The proxy doesn't check the server response and assumes the upgrade was successful. Any further communications will be tunneled since the proxy believes they are part of an upgraded WebSocket connection.
	![](Pasted%20image%2020250215032752.png)

It is important to note that this technique won't allow us to poison other users' backend connections. We will be limited to tunnelling requests through the proxy only, so we can bypass any restrictions imposed by the frontend proxy by using this trick.

## Bypassing Proxy Restrictions
Let's check the application at `http://MACHINE_IP:8001/flag`. This application is running behind a **Varnish** proxy with a vulnerable configuration. Our objective in this application is to retrieve the value stored in `/flag`.

As a first attempt, if we try to access `/flag` directly, we are presented with the following message:
	![](Pasted%20image%2020250215033331.png)

This error message was sent by Varnish (the proxy) instead of the backend application, which should be interesting. If we try accessing another non-existent resource like `http://MACHINE_IP:8001/nonexistent134`, the error message presented will be different. At this point, we should be suspicious that the frontend proxy is restricting access to `/flag` in the backend web server.

Luckily, there's also a WebSocket endpoint we can abuse at `http://MACHINE_IP:8001/socket`. Let's send the following payload to try to smuggle a request for the flag inside a broken WebSocket connection:

```shell
GET /socket HTTP/1.1
Host: MACHINE_IP:8001
Sec-WebSocket-Version: 777
Upgrade: WebSocket
Connection: Upgrade
Sec-WebSocket-Key: nf6dB8Pb/BLinZ7UexUXHg==

GET /flag HTTP/1.1
Host: MACHINE_IP:8001
```

To send the request, we will use Burp's Repeater. To ensure Burp doesn't modify our request and break the attack, we need to make sure the `Update Content-Length` setting is disabled:
	![](Pasted%20image%2020250215033435.png)

Once this is done, we can send our payload and should get the flag (note the two newlines at the end of the payload):
	![](Pasted%20image%2020250215033506.png)

Just as expected, we get a `426` error from the initial attempt to upgrade the connection to a WebSocket. At this point, the proxy believes the rest of the connection uses the WebSocket protocol and will tunnel everything directly to the backend server, including our smuggled request for `/flag`.


## What if the App Doesn't Speak WebSocket?
Note that some proxies will not even require the existence of a WebSocket endpoint for this technique to work. All we need is to fool the proxy into believing we are establishing a connection to a WebSocket, even if this isn't true. Look at what happens if you try to send the following payload:

```shell
GET / HTTP/1.1
Host: MACHINE_IP:8001
Sec-WebSocket-Version: 13
Upgrade: WebSocket
Connection: Upgrade
Sec-WebSocket-Key: nf6dB8Pb/BLinZ7UexUXHg==

GET /flag HTTP/1.1
Host: MACHINE_IP:8001
```

This payload should still work, even though the first request is directed to `/`, which is not a WebSocket-enabled endpoint. The proxy simply doesn't check the response from the upgrade, so you can use any payload that looks close enough to a WebSocket upgrade.