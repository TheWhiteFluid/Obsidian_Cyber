Basic SSRF is a web attack technique where an attacker tricks a server into making requests on their behalf, often targeting internal systems or third-party services. By exploiting vulnerabilities in input validation, the attacker can gain unauthorised access to sensitive information or control over remote resources, posing a significant security risk to the targeted application and its underlying infrastructure.
﻿
A basic SSRF can be employed against a local or an internal server. 

## SSRF Against a Local Server
In this attack, the attacker makes an unauthorised request to the server hosting the web application. The attacker typically supplies a loopback IP address or localhost to receive the response. The vulnerability arises due to how the application handles input from the query parameter or API calls.

For example, in the HRMS application, there's a feature that loads additional pages based on a URL parameter. For example, navigating to `http://hrms.thm?url=localhost/copyright` would load the copyright page of the application. This feature is intended for internal use and is designed to request and display pages from the local server (hence using `localhost` in the query).

However, due to insufficient validation of the input URL, an attacker can manipulate this functionality for SSRF attacks. By changing the URL parameter to point to other pages/services, the attacker can force the HRMS server to make requests to other pages. For instance, if the attacker uses a URL like `http://hrms.thm/?url=localhost/config`, and `config` is a valid page, the HRMS server will attempt to fetch content from this page and display the result.

*Note*:
	The main idea is to forge a legitimate request and make the server perform an unintended action.

### **How it works**
- Suppose you have been tasked to pentest the HRMS website and identify any SSRF loopholes. Visit the HRMS website `http://hrms.thm`, and you will see that the login page is protected through a username and password.
	![](Pasted%20image%2020250117160257.png)
- We will notice that once we visit the page `http://hrms.thm`[](http://hrms.thm/), it automatically redirects to `http://hrms.thm/?url=localhost/copyright`. The webpage shows the copyright status of the website.
	![](Pasted%20image%2020250117160325.png)
- This means the developer has probably made some mistakes while handling a file showing the copyright status. Here is the code of the page that takes the query parameter.
```php
$uri = rtrim($_GET['url'], "/");
...					
$path = ROOTPATH . $file;
...
if (file_exists($path)) {
  echo "<pre>";
  echo htmlspecialchars(file_get_contents($path));
  echo "</pre>";
  } else { ?>
    <p class="text-xl"><?= ltrim($file, "/") ?> is not found</p>
 <?php
... 
```

- We can see in the above code that the input parameter `url` lacks adequate filtering and loads whatever the parameter is provided from the `localhost`.
- Let's try to change the URL from `http://hrms.thm/?url=localhost/copyright` to `http://hrms.thm/?url=localhost/hello`; it displays an error that `hello.php is not found`.
- When we try to access the file `http://hrms.thm/?url=localhost/config`, we will see that the footer of the page shows the content of the file, essentially showing us the exact credentials, which would look like this:

```php
<?php 
$adminURL = "xxxxxxx";
$username = "xxxxx"; 
$password = "xxxx"; 
...
?>
```

As a penetration tester, it's crucial to know that Basic SSRF vulnerabilities are frequently present across various types of websites, including e-commerce, banking, management systems, and more, particularly in features involving file handling or external resource fetching.


## Accessing an Internal Server
In complex web applications, it is common for front-end web applications to interact with back-end internal servers. These servers are generally hosted on **non-routable IP addresses**, so an internet user cannot access them. In this scenario, an attacker exploits a vulnerable web application's input validation to trick the server into requesting **internal resources on the same network**. They could provide a malicious URL as input, making the server interact with the internal server on their behalf.

For instance, if an internal server provides database management or administrative controls, the attacker could craft a URL that initiates an unintended action on these internal systems when processed by the vulnerable web application. Technically, this is achieved through manipulated input, such as special IP addresses (like `192.168.x.x` or `10.x.x.x` for IPv4) or domain names (e.g., `internal-database.hrms.thm`). When not properly sanitised, these inputs can be used in functions like HTTP requests or file inclusions within the web application. The server, interpreting these requests as legitimate, then inadvertently performs actions or retrieves data from other internal services.

Moreover, since these internal servers may lack the same level of security monitoring as external-facing servers, such exploitation can often go unnoticed. The attacker might also use this method to perform reconnaissance within the internal network, identifying other vulnerable systems or services to target.

### **How it works**
- In this case, we will try to access the inaccessible internal resources through direct request.
- Now that we have acquired the credentials for the login panel, we will log in to the dashboard.
- Once we log in to the HRMS web app, we will see a dashboard listing employees and their departments. There is a dropdown that shows employees' data and salary.
	![](Pasted%20image%2020250117180910.png)
- From the config file, we can see that the admin panel is hosted at `http://192.168.2.10/admin.php`. If we try to log in to the admin panel, it is not accessible directly. Let's try to access it; it will show an error.
	![](Pasted%20image%2020250117180949.png)
- We have no route to that IP as it's a private network IP and can only be accessed by a machine within the same network.
- If we check the source of the HTML, it shows that the dropdown takes the URL from an **internal system** and renders the data. The details of all employees are being rendered from `http://192.168.2.10/employees.php`.
	![](Pasted%20image%2020250117181108.png)
- That's great, so the dropdown is accessing an internal system; what if we try to change the request such that instead of loading the employee page, we forge the request and send `http://192.168.2.10/admin.php` as a parameter to the server? 
- Use the Inspect Element option and change the drop down value of salary from `http://192.168.2.10/salary.php` to `http://192.168.2.10/admin.php` as shown below:
	![](Pasted%20image%2020250117181206.png)
- Once you update the value, choose the `Salary` option from the `Select Category` dropdown. In this way we got access to the admin panel that was earlier inaccessible from the same IP.