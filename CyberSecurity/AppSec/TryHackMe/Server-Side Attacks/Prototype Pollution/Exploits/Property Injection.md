
## Few Important Functions
### **Object Recursive Merge** 
 This function involves recursively merging properties from source objects into a target object. An attacker can exploit this functionality if the merge function does not validate its inputs and allows merging properties into the prototype chain. Considering the same social network example, let's assume the following code. Suppose the application has a function to merge user settings:

```javascript
// Vulnerable recursive merge function
function recursiveMerge(target, source) {
    for (let key in source) {
        if (source[key] instanceof Object) {
            if (!target[key]) target[key] = {};
            recursiveMerge(target[key], source[key]);
        } else {
            target[key] = source[key];
        }
    }
}

// Endpoint to update user settings
app.post('/updateSettings', (req, res) => {
    const userSettings = req.body; // User-controlled input
    recursiveMerge(globalUserSettings, userSettings);
    res.send('Settings updated!');
});
```

An attacker sends a request with a nested object containing `__proto__`:
```javascript
{ "__proto__": { "newProperty": "value" } }
```

### **Object Clone** 
 Object cloning is a similar functionality that allows deep clone operations to copy properties from the prototype chain to another one inadvertently. Testing should ensure that these functions only clone the user-defined properties of an object and filter special keywords like __proto__, constructor, etc. A possible use case is that the application backend clones objects to create new user profiles:


## Example
 Let's explore the Clone album feature. The clone album allows users to clone an album by providing a new name.
	 ![](Pasted%20image%2020250125041756.png)
Let's explore the client-side and server-side code to explore various exploitation possibilities.

```html
<form action="/clone-album/1" method="post" class="mb-4">
        <h2 class="mb-3">Clone Album of Josh</h2>
        <div class="form-group">
            <label for="selectedAlbum">Select an Album to Clone:</label>
            <select class="form-control" name="selectedAlbum" id="selectedAlbum">
                    <option value="Trip to US">
                        Trip to US
                    </option>
            </select>
        </div>
        <div class="form-group">
            <label for="newAlbumName">New Album Name:</label>
            <input type="text" class="form-control" name="newAlbumName" id="newAlbumName"
                placeholder="Enter new album name">
        </div>
        <button type="submit" class="btn btn-primary">Clone Album</button>
    </form>
```

The client-side code takes the name as input and calls the API endpoint `/clone-album/{album_ID}` to clone the album. As discussed in previous tasks, Prototype pollution alone is rarely exploitable; however, once combined with other attack vectors like XSS, it can provide a better attack surface. Now, let's go through the server-side code.

```javascript
app.post("/clone-album/:friendId", (req, res) => {
  const { friendId } = req.params;
  const { selectedAlbum, newAlbumName } = req.body;
  const friend = friends.find((f) => f.id === parseInt(friendId));
  if (!friend) {
    console.log("Friend not found");
    return res.status(404).send("Friend not found");
  }
  const albumToClone = friend.albums.find(
    (album) => album.name === selectedAlbum
  );
  if (albumToClone && newAlbumName) {
    let clonedAlbum = { ...albumToClone };
    try {
      const payload = JSON.parse(newAlbumName);
      merge(clonedAlbum, payload);
    } catch (e) {
    }

function merge(to, from) {
  for (let key in from) {
    if (typeof to[key] == "object" && typeof from[key] == "object") {
      merge(to[key], from[key]);
    } else {
      to[key] = from[key];
    }
  }
  return to;
}
```

In the above code,  the servers receive a JSON object containing the album's name, copy the album that needs to be copied into another object, and change the name of the newly created copy by calling the merge function.  

We know the *merge* function is an ideal candidate for prototype pollution if it blindly copies all the objects and properties without sanitising based on keys. We can see that the merge function made by the developer lacked any such sanitisation filters. What if we send a request that contains `__proto__` with a `newProperty`  and value as mentioned below:

```javascript
{"__proto__": {"newProperty": "hacked"}}
```

The merge function will consider the `__proto__`  as a property and will call `obj.__proto__.newProperty=value`. By doing this, `newProperty` is not added directly to the friend object. Instead, it's added to the friend object's prototype. This means `newProperty` is not visibly part of the friend's properties (like name, age, etc.) but is still accessible. Let's clone an album by visiting Josh's profile and using the above payload as an album name.
	![](Pasted%20image%2020250125043550.png)

- **Effect on All Objects of the Same Type**: Since all friend objects share the same prototype (they are created from the same template or constructor), adding `newProperty` to the prototype means all friend objects now have access to newProperty. It's like adding a new feature to the template; now, every object created from that template has this new feature.
- **Observing the Change**: Even though `newProperty` is not directly visible when you print the friend object, it is still there. You can access it by calling `friend.newProperty`, which will show "`testValue`".
- **How newProperty Becomes Visible**: When you add newProperty via the prototype, it doesn't exist directly on the individual objects (like each friend) but on their prototype. However, when you access a property on an object, JavaScript first looks for that property on the object itself. If it's not found, JavaScript looks up the prototype chain until it finds it (or reaches the end of the chain).
- **Rendering on Screen**: In the [EJS](https://ejs.co/) template, when you loop through the properties of a friend object using a `for...in loop` (`<% for (let key in friend) { %> ... <% } %>`) and display them, this loop iterates over all enumerable properties of the friend object, including those inherited from the prototype. Therefore, even though newProperty is not directly on the friend object but on its prototype, it still shows up in this loop and is rendered on the screen.


Create a new property with the name **isBanned** with default value **true**. What is the flag value after creating the property?
	![](Pasted%20image%2020250125045830.png)