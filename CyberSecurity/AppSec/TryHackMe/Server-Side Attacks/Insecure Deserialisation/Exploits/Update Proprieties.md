
## Updating Properties of an Object
Let's explore a practical example in PHP, using a simple note-sharing application as our case study. Our note-sharing application allows users to create, save, and share notes easily. Users can input their notes into the application, which are then saved for future reference. Additionally, users can share their notes with others, facilitating collaboration and information exchange. The application also includes subscription-based features, ensuring only subscribed users can access certain functionalities such as note sharing.
	![](Pasted%20image%2020250116203059.png)

### **Defining the Notes Class**
The application has a `Notes` class, representing a note in our application. This class has three private properties: `user`, `role`, and `isSubscribed`. We also have setter and getter methods to manipulate the `isSubscribed` property.  

```php
class Notes {

    private $user;
    private $role;
    private $isSubscribed;

    public function __construct($user, $role, $isSubscribed) {
        $this->user = $user;
        $this->role = $role;
        $this->isSubscribed = $isSubscribed;
    }

    public function setIsSubscribed($isSubscribed) {
        $this->isSubscribed = $isSubscribed;
    }

    public function getIsSubscribed() {
        return $this->isSubscribed;
 }
}
```

### **Storing User Data in Cookies**
When a user visits our application for the first time, it sets a serialised cookie containing their user data. This includes their user name, role, and subscription status (`isSubscribed`). If the user is a paid member (**isSubscribed = true**), they are allowed to share notes.
	![](Pasted%20image%2020250116203729.png)

## **Exploiting the Vulnerability**
In this step, we'll illustrate how an attacker can exploit the vulnerability by modifying the serialised cookie value to gain unauthorised access to share notes.

- **Serialised cookie**: After decoding the base64-encoded cookie value, we obtain the following serialised representation of the Notes object:

```php
O:5:"Notes":3:{s:4:"user";s:5:"guest";s:4:"role";s:5:"guest";s:12:"isSubscribed";b:0;}
```

As we already know, in PHP serialisation, the class name is prefixed to the property names in case it is not public to ensure uniqueness and help with deserialisation. This is a part of how PHP handles object serialisation and deserialisation internally. When an object is serialised, PHP stores the object's properties and class name. This ensures that when the object is later deserialised, PHP knows which class to instantiate and how to assign the serialised data to the object's properties correctly. Let's break down the serialised note into its components:

- **O:5:"Notes":3**: This represents an object (O) with the class name Notes, which has three properties.
- **s:4:"user";s:5:"guest"**: This indicates a string (s) with a length of 4 characters, representing the property `user` with the value "**guest**".
- **s:4:"role";s:5:"guest"**: Similar to the previous one, it represents the property `role` with the value "**guest**".
- **s:12:"isSubscribed";b:0**: This represents a boolean (b) property named `isSubscribed` with the value of false (0).

In the current scenario, when the user would like to try to share the note, they get the following pop-up:
	![](Pasted%20image%2020250116204209.png)

Now, what is happening on the backend? The backend PHP code validates the incoming cookie, deserializes it, and then validates whether the user is subscribed. Our main task is to bypass that.

Suppose an attacker intercepts this serialised cookie value and modifies the `isSubscribed` property from false (0) to true (1). The attacker can manipulate the subscription status without legitimate authorisation by changing the boolean value in the serialised data.

After modifying, the attacker would base64 encode the serialised data again and replace the original cookie value with the modified one. This would grant them unauthorised access to share notes on other platforms, bypassing the intended subscription restrictions.