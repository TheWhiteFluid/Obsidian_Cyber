The second common mistake with JWTs is not correctly verifying the signature. If the signature isn't correctly verified, a threat actor may be able to forge a valid JWT token to gain access to another user's account. Let's examine the common signature verification issues.

## Not Verifying the Signature
The first issue with signature validation is when there is no signature validation. If the server does not verify the signature of the JWT, then it is possible to modify the claims in the JWT to whatever you prefer them to be. While it is uncommon to find APIs where no signature validation is performed, signature validation may have been omitted from a single endpoint within the API. Depending on the sensitivity of the endpoint, this can have a significant business impact.

### Example1
Let's authenticate to the API:
```
curl -H 'Content-Type: application/json' -X POST -d '{ "username" : "user", "password" : "password2" }' http://10.10.66.238/api/v1.0/example2
```

Once authenticated, let's verify our user:
```
curl -H 'Authorization: Bearer {JWT Token}' http://10.10.66.238/api/v1.0/example2?username=user
```

However, let's try to verify our user without the signature, remove the third part of the JWT (leaving only the dot) and make the request again. You will see that the verification still works! This means that the signature is not being verified. Modify the admin claim in the payload to be `1` and try to verify as the admin user to retrieve your flag.
	![](Pasted%20image%2020241129192432.png)![](Pasted%20image%2020241129193332.png)
	![](Pasted%20image%2020241130173349.png)
	![](Pasted%20image%2020241129193513.png)

### The Development Mistake
In the example, the signature is not being verified, as shown below:

```python
payload = jwt.decode(token, options={'verify_signature': False})
```

﻿While it is rare to see this on normal APIs, it often happens on server-to-server APIs. In cases where a threat actor has direct access to the backend server, JWTs can be forged.

### The Fix  
The JWT should always be verified or additional authentication factors, such as certificates, should be used for server-to-server communication. The JWT can be verified by providing the secret (or public key), as shown in the example below:

```python
payload = jwt.decode(token, self.secret, algorithms="HS256")
```

## Downgrading to None
Another common issue is a signature algorithm downgrade. JWTs support the `None` signing algorithm, which effectively means that no signature is used with the JWT. While this may sound silly, the idea behind this in the standard was for server-to-server communication, where the signature of the JWT was verified in an upstream process. Therefore, the second server would not be required to verify the signature. However, suppose the developers do not lock in the signature algorithm or, at the very least, deny the `None` algorithm. In that case, you can simply change the algorithm specified in your JWT as `None`, which would then cause the library used for signature verification to always return true, thus allowing you again to forge any claims within your token.

### Example2
Authenticate to the API to receive your JWT and then verify your user. To perform this attack, you will need to manually alter the  the `alg` claim in the header to be `None`. You can use [CyberChef](https://gchq.github.io/CyberChef/) for this making use of the URL-Encoded Base64 option. Submit the JWT again to verify that it is still accepted, even if the signature is no longer valid, as changes have been made. You can then alter the `admin` claim to recover the flag.
	![](Pasted%20image%2020241130172528.png)![](Pasted%20image%2020241130172540.png)
- we will take the header value and we will use CyberChef to modify `alg` value and encode it back
	![](Pasted%20image%2020241130172653.png)
- using JWT.io we will alter the payload 
	  ![](Pasted%20image%2020241130173024.png)
- combining all the piece together to bypass authorization
  ![](Pasted%20image%2020241130173152.png)
### The Development Mistake
While this may seem like the same issue as before, from a development perspective, it is slightly more complex. Sometimes, developers want to ensure their implementation accepts several JWT signature verification algorithms. The implementation would then usually read the header of the JWT and parse found alg into the signature verification component, as shown below:
```python
header = jwt.get_unverified_header(token)

signature_algorithm = header['alg']

payload = jwt.decode(token, self.secret, algorithms=signature_algorithm)
```

However, when the threat actor specified `None` as the algorithm, signature verification is bypassed. [Pyjwt](https://pyjwt.readthedocs.io/en/stable/), the JWT library used in this room, has implemented security coding to prevent this issue. If a secret is specified when the None algorithm is selected, an exception is raised.

### The Fix  
If multiple signature algorithms should be supported, the supported algorithms should be supplied to the decode function as an array list, as shown below:
```python
payload = jwt.decode(token, self.secret, algorithms=["HS256", "HS384", "HS512"])

username = payload['username']
flag = self.db_lookup(username, "flag")
```

## Weak Symmetric Secrets
If a symmetric signing algorithm is used, the security of the JWT relies on the strength and entropy of the secret used. If a weak secret is used, it may be possible to perform offline cracking to recover the secret. Once the secret value is known, you can again alter the claims in your JWT and recalculate a valid signature using the secret.

### Example3
For this example, a weak secret was used to generate the JWT. Once you receive a JWT, you have several options to crack the secret. For our example, we will talk about using [Hashcat](https://hashcat.net/hashcat/) to crack the JWT's secret. You could also use other solutions such as [John](https://www.openwall.com/john/) as well. You can use the following steps to crack the secret:

1. Save the JWT to a text file called jwt.txt.
2. Download a common JWT secret list. For this room, you can use `wget https://raw.githubusercontent.com/wallarm/jwt-secrets/master/jwt.secrets.list` to download such a list.
3. Use Hashcat to crack the secret using `hashcat -m 16500 -a 0 jwt.txt jwt.secrets.list`

Once you know what the secret is, you can forge a new admin token to recover the flag!
	![](Pasted%20image%2020241130175844.png)![](Pasted%20image%2020241130180227.png)![](Pasted%20image%2020241130180717.png)![](Pasted%20image%2020241130180743.png)

### The Development Mistake
The issue occurs when a weak JWT secret is used. This can often occur when developers are in a hurry or copy code from examples.

### The Fix  
A secure secret value should be selected. As this value will be used in software and not by humans, a long, random string should be used for the secret.


## Signature Algorithm Confusion
The last common issue with signature validation is when an algorithm confusion attack can be performed. This is similar to the `None` downgrade attack, however, it specifically happens with confusion between symmetric and asymmetric signing algorithms. *If an asymmetric signing algorithm, for example, RS256 is used, it may be possible to downgrade the algorithm to HS256*. In these cases, some libraries would default back to using the public key as the secret for the symmetric signing algorithm. Since the public key can be known, you can forge a valid signature by using the HS256 algorithm in combination with the public key.

### Example 4
In this scenario, the **None algorithm** is disabled, but you can still exploit a vulnerability by **downgrading the algorithm** to **HS256** and using the **public key** (commonly considered non-sensitive) as the secret to sign the JWT. Here's how it works:

- **Obtain the Public Key:**  
    Authenticate to the system and retrieve the public key, either from the JWT claims or another source.
    
- **Modify the JWT:**  
    Change the algorithm in the JWT header from `RS256` to `HS256`.
    
- **Sign the JWT:**  
    Use the public key as the secret to sign the JWT with HS256.
    
- **Send the Forged JWT:**  
    Submit the modified JWT to gain access or privileges.

```
import jwt 

public_key = "ADD_KEY_HERE" 

payload = { 
'username' : 'user', 
'admin' : 0 
} 

access_token = jwt.encode(payload, public_key, algorithm="HS256") 
print (access_token)
```

Before running the script, edit the file `/usr/lib/python3/dist-packages/jwt/algorithms.py` using your favorite text editor and go to line `143`. Then proceed to comment out lines `143-146` and run the script. If you are using your own VM, you may have to install Pyjwt (`pip3 install pyjwt`) to use this script. You will also need to tamper with the Pyjwt library's algorithm.py file on line `258` to remove the `is_ssh_key` condition as a patch for this vulnerability was released. Keep in mind that this placement can vary per VM and installation. An easier method if you are not comfortable with library code edits is to make use of [jwt.io](https://jwt.io/). Once you verify it works, you can alter the claims to make yourself an admin and recover the flag.
	![](Pasted%20image%2020241130181924.png)![](Pasted%20image%2020241130183509.png)![](Pasted%20image%2020241130182916.png)
- use the generated token for authentication  
	![](Pasted%20image%2020241130183525.png)

### The Development Mistake
The mistake in this example is similar to that of example 2 but a bit more complex. While the None algorithm is disallowed, the key issue stems from both symmetric and asymmetric signature algorithms being allowed, as shown in the example below:
```python
payload = jwt.decode(token, self.secret, algorithms=["HS256", "HS384", "HS512", "RS256", "RS384", "RS512"])
```

*Note:*
	Care should be given never to mix signature algorithms together as the secret parameter of the decode function can be confused between being a secret or a public key.

### The Fix  
While both types of signature algorithms can be allowed, a bit more logic is required to ensure that there is no confusion, as shown in the example below:
```python
header = jwt.get_unverified_header(token)

algorithm = header['alg']
payload = ""

if "RS" in algorithm:
    payload = jwt.decode(token, self.public_key, algorithms=["RS256", "RS384", "RS512"])
elif "HS" in algorithm:
    payload = jwt.decode(token, self.secret, algorithms=["HS256", "HS384", "HS512"])

username = payload['username']
flag = self.db_lookup(username, "flag")
```