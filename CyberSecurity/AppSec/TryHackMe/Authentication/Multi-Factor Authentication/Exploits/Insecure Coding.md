In some applications, flawed logic or insecure coding practices can lead to a situation where critical parts of the application (i.e., the dashboard) can be accessed without fully completing the authentication process. Specifically, an attacker might be able to bypass the 2FA mechanism entirely and gain access to the dashboard or other sensitive areas without entering the OTP (One-Time Password). This is often due to improper session management, poor access control checks, or incorrectly implemented logic that fails to enforce the 2FA requirement.

## Exploitation
![](Pasted%20image%2020241204173222.png)

Typically, the attacker first needs to understand how the application’s login and 2FA process work. In this case, after entering the username and password, the user is prompted to enter an OTP to gain access to the dashboard.
	![](Pasted%20image%2020241204173308.png)
Instead of entering the OTP, the attacker might try to manipulate the URL or bypass the OTP step altogether. For example, the attacker might try to directly access the dashboard URL (e.g., `http://mfa.thm/labs/second/dashboard`) without completing the required authentication steps.

If the application doesn't properly check the session state or enforce 2FA or the application's logic is flawed, the attacker might gain access to the dashboard.
	![](Pasted%20image%2020241204173521.png)

## Diving deeper into the code
The below code is part of the code that is used in the **/mfa** page. As you can see, the $SESSION['authenticated'] is issued after the completion of the 2FA process.

```php
# Function that verifies the submitted 2FA token
function verify_2fa_code($code) {
    if (!isset($_SESSION['token']))
    return false;

    return $code === $_SESSION['token'];
}

# Function called in the /mfa page
if (verify_2fa_code($_POST['code'])) { #If successful, the user will be redirected to the dashboard.
    $_SESSION['authenticated'] = true; # Session that is used to check if the user completed the 2FA
    header('Location: ' . ROOT_DIR . '/dashboard');
    return;
}
```

Considering the above implementation is secure, some instances of dangling issuance of the $SESSION['authenticated'] after the first step of authentication will bypass the above code, as shown below.
```php
function authenticate($email, $password){
  $pdo = get_db_connection();
  $stmt = $pdo->prepare("SELECT `password` FROM users WHERE email = :email");
  $stmt->execute(['email' => $email]);
  $user = $stmt->fetch(PDO::FETCH_ASSOC);

  return $user && password_verify($password, $user['password']);
}

if (authenticate($email, $password)) {
    $_SESSION['authenticated'] = true; # This flag should only be issued after the MFA completion
    $_SESSION['email'] = $_POST['email'];
    header('Location: ' . ROOT_DIR . '/mfa');
    return;
}
```

Since the application's dashboard only checks for the value of $SESSION['authenticated'], whether it's true or false, the attacker can easily bypass the 2FA page, considering the attacker has prior knowledge of the application's endpoints.

To remediate this vulnerability, the cookie or session that is used in authentication checks should be split into two parts. The first part is the one that sets the session after successful username and password verification; the sole purpose of this session is to submit a 2FA token. The second session should only be after the OTP is validated.

## Explanation
1. **MFA Verification Logic:**
	``` php
	if (verify_2fa_code($_POST['code'])) {
    $_SESSION['authenticated'] = true; 
    header('Location: ' . ROOT_DIR . '/dashboard');
    return;
}```
    - The `$_SESSION['authenticated']` flag is only set after successful 2FA verification. This is secure **if** the user reaches this part of the code.
    
2. **Authentication Logic (Vulnerability):**
    ```php
    if (authenticate($email, $password)) {
    $_SESSION['authenticated'] = true; 
    $_SESSION['email'] = $_POST['email'];
    header('Location: ' . ROOT_DIR . '/mfa');
    return;
}```
- **Issue:** The `$_SESSION['authenticated']` is prematurely set **after password authentication** but **before** completing the 2FA step.
    - **Impact:** Since the dashboard only checks the value of `$_SESSION['authenticated]`, an attacker could skip the `/mfa` step and directly access the dashboard.

---

### **Why is this Dangerous?**
An attacker with knowledge of the application’s endpoints (e.g., `/dashboard`) could:

- Submit valid credentials.
- Be redirected to `/mfa`, but instead of completing 2FA, directly navigate to `/dashboard`, which only checks if `$_SESSION['authenticated'] = true`.

---

### **Recommended Remediation: Splitting Sessions**
To fix this, we can introduce a **two-step session approach**:

#### 1. **First Session: Authentication Phase (Pre-MFA):**
- After validating the email and password, set a **temporary session variable** to indicate that the user has passed the first step (username/password verification).
- Do **not** set `$_SESSION['authenticated]` at this point.
```php
if (authenticate($email, $password)) {
    $_SESSION['auth_step'] = 'password_verified'; 
    $_SESSION['email'] = $_POST['email'];
    header('Location: ' . ROOT_DIR . '/mfa');
    return;
}
```

#### 2. **Second Session: Post-MFA Completion:**
- After successfully verifying the 2FA token, set the `$_SESSION['authenticated']` flag.
```php
if (verify_2fa_code($_POST['code']) && $_SESSION['auth_step'] === 'password_verified') {
    unset($_SESSION['auth_step']); // Clean up temporary session variable
    $_SESSION['authenticated'] = true;
    header('Location: ' . ROOT_DIR . '/dashboard');
    return;
}
```
