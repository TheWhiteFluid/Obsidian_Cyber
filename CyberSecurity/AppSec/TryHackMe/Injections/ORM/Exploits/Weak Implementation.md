![](Pasted%20image%2020250112191848.png)

Let's take a closer look at the source code used by the developer: to Let's take a closer look at the source code used by the developer for the **Email (Vulnerable)** input field:
```php
public function searchBlindVulnerable(Request $request)
{
    $users = [];
    $email = $request->input('email');
    $users = Admins::whereRaw("email = '$email'")->get();
    if ($users) {
        return view('user', ['users' => $users]);
    } else {
        return view('user', ['message' => 'User not found']);
    }
}
```

The `searchBlindVulnerable()` function is designed to retrieve user records based on the email parameter provided by the user. Here's a detailed breakdown of the function:
- **Retrieve input**: The function captures the `email` parameter from the HTTP request. This is done using the input method of the `$request` object.
- **Construct query**: The function then constructs a raw SQL query using Laravel's `whereRaw()` method, which directly incorporates the email value into the SQL statement.
- **Execute query**: This query is executed, storing the result in the `$users` variable.
- **Return view**: Finally, the function returns a view. If the `$users` array is not empty, it passes the user data to the view; otherwise, it passes a "**User not found**" message.

The critical issue in this function lies in the direct use of `whereRaw()` with user input. This method of query construction is vulnerable to injection attacks because it does not sanitise the input.

An attacker can exploit this vulnerability by manipulating the email parameter. If an attacker inputs `1' OR '1'='1`, the resulting SQL query becomes:
```php
SELECT * FROM users WHERE email = '1' OR '1'='1';
```

Detailed Exploitation 
- **Input malicious value**: The attacker visits the input field on the website and enters a crafted input, such as `1' OR '1'='1`.
- **Query construction**: The `searchBlindVulnerable()` function receives this input and constructs the following query using `whereRaw()`:

```php
$users = User::whereRaw("email = '1' OR '1'='1'")->get();
```

This raw query construction directly inserts the malicious input into the SQL query.
- **Query execution**: Laravel's Eloquent ORM translates this into the SQL statement `SELECT * FROM users WHERE email = '1' OR '1'='1';`.
- **Result**: Since `'1'='1'` is always true, the query returns all records in the user's table. The attacker now has access to potentially sensitive information about all users in the database as shown below:
	![](Pasted%20image%2020250112192230.png)

## Implementing Secure ORM Queries
Let's look at a secure version of the query function to demonstrate how secure implementation can protect against ORM injection vulnerabilities. By using parameterised queries, we can ensure that user inputs are properly sanitised, significantly reducing the risk of injection attacks. Here’s a secure implementation of the function via the **Email (Secure)** input field:
``` php
public function searchBlindSecure(Request $request)
{
    $email = $request->input('email');
    $users = User::where('email', $email)->get();
    if (isset($users) && count($users) > 0) {
        return view('user', ['users' => $users]);
    } else {
        return view('user', ['message' => 'User not found']);
    }
}
```

- **Retrieving input**: The function captures the email parameter from the HTTP request using the input method of the `$request` object. This is the same as in the vulnerable version.
- **Constructing the query securely**: Instead of using `whereRaw()`, the secure version uses Eloquent `where()` method. This method automatically escapes the input, thus preventing SQL injection. The `where()` method constructs a parameterised query behind the scenes, ensuring that user input is not directly included in the SQL statement.
- **Executing the query**: The query is executed, and the result is stored in the `$users` variable. Because the query is parameterised, the input is sanitised, which means it cannot break the SQL query structure.
- **Returning the view**: Finally, the function returns a view. If the `$users` array contains data, it passes the user data to the view; otherwise, it shows an error message. This logic ensures that only valid data is processed and displayed.

Now, try using the same malicious payload `1' OR '1'='1` with the secure implementation. When you submit this input, you will notice that the application does not break or return all user data. Instead, it behaves as expected, either finding no user with that email or returning the appropriate user data if a valid email is provided.

### Why This Is Secure
- **Parameterised queries**: Parameterised queries ensure that the input values are treated as data only, not executable code. This prevents any injected SQL from being executed.
- **Automatic escaping**: Eloquent automatically escapes the input values, negating any special characters that could be used for SQL injection.
- **Consistent query logic**: By using Eloquent methods like `where()`, the query logic remains consistent and clear, making it easier to maintain and audit for security.