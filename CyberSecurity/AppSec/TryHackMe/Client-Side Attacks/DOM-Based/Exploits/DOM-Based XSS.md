DOM-based XSS is a subsection of DOM-based attacks. However, it is the most potent form of DOM-based attack, as it allows you to inject JavaScript code and take full control of the browser. As with all DOM-based attacks, we need a source and a sink to perform the attack.

The most common source for DOM-based XSS is the URL and, more specifically, URL fragments, which are accessed through the `window.location` source. This is because we have the ability to craft a link with malicious fragments to send to users. In most cases, fragments are not interpreted by the web server but reflected in the response, leading to DOM-based XSS. However, it should be noted that most modern browsers will perform URL encoding on the data, which can prevent the attack. This has led to a decrease in the prevalence of these types of attacks through the URL as source. Let's look at an example where a fragment in the URL can be used as a source.

Continuing with our web page location example, let's take a look at the following jQuery example to navigate the page to the last viewed location:

```javascript
$(window).on('hashchange', function() {
	var element = $(location.hash);
	element[0].scrollIntoView();
});
```

Since the hash value is a source that we have access to, we can inject an XSS payload into jQuery's $() selector sink. For example, if we were able to set the URL as follows:

```
https://realwebsite.com#<img src=1 onerror=alert(1)></img>  
```

However, this would only allow us to XSS ourselves. To perform XSS on other users, we need to find a way to trigger the `hashchange` function automatically. The simplest option would be to leverage an iframe to deliver our payload:

```
<iframe src="https://realwebsite.com#" onload="this.src+='<img src=1 onerror=alert(1)>'
```

Once the website is loaded, the `src` value is updated to now include our XSS payload, triggering the `hashchange` function and, thus, our XSS payload.

This is one example of how XSS can be performed. However, several other sinks could be used. This includes normal JavaScript sinks and framework-specific ones such as those for jQuery and Angular. For a complete list of the available sinks, you can visit [this page](https://portswigger.net/web-security/cross-site-scripting/dom-based). 

*Note:*
	The tricky part lies in the weaponization of DOM-based XSS. Without proper weaponization, we are simply performing XSS on ourselves, which has no value. This is a key issue with DOM-based XSS. 


## **Common Sinks**

The following are some of the main sinks that can lead to DOM-XSS vulnerabilities:
``` javascript
document.write() 
document.writeln()
document.domain 
element.innerHTML
element.outerHTML 
element.insertAdjacentHTML 
element.onevent
```

The following jQuery functions are also sinks that can lead to DOM-XSS vulnerabilities:
``` javascript
add()
after()
append()
animate()
insertAfter()
insertBefore()
before()
html()
prepend()
replaceAll()
replaceWith()
wrap()
wrapInner()
wrapAll()
has()
constructor()
init()
index()
jQuery.parseHTML()
$.parseHTML()
```


## **DOM-Based XSS vs Conventional XSS**

When testing for **Cross-Site Scripting (XSS)** vulnerabilities, you might encounter different types:
1. **Stored XSS**
    
    - The malicious script is permanently stored on the server (e.g., in a database).
    - Each time a user visits the affected page, the script is served in the response and executed in their browser.
      
2. **Reflected XSS**
    
    - The malicious script is included in a request (e.g., via a URL parameter) and reflected back in the response.
    - The attack requires a user to click a link or visit a malicious page.
      
3. **DOM-Based XSS**
    
    - The malicious script is **not** present in the server's response.
    - Instead, it is introduced and executed in the **DOM (Document Object Model)** after the page has loaded, through JavaScript.
    - The sink (where the malicious script executes) is in the JavaScript code running in the browser, rather than on the server.


### **How to Identify the Difference?**
- If the **server response already contains the injected payload**, it's **conventional XSS** (stored or reflected).
- If the **payload is injected into the DOM after the page loads**, via JavaScript functions, it's **DOM-based XSS**.


### **Mitigation Strategies**
- **For stored or reflected XSS** (server-side injection):
    
    - Use **HTML entity encoding** on the server before rendering user input.
    - Implement Content Security Policy (CSP) to block script execution.
      
- **For DOM-based XSS** (client-side injection):
    
    - Identify the JavaScript function that processes untrusted data.
    - Avoid functions like `innerHTML`, `document.write`, and `eval()`.
    - Use safer alternatives like `textContent` or `createTextNode()`.