Cron jobs are used to run scripts or binaries at specific times. By default, they run with the privilege of their owners and not the current user. While properly configured cron jobs are not inherently vulnerable, they can provide a privilege escalation vector under some conditions.  
  
Cron job configurations are stored as crontabs (cron tables) to see the next time and date the task will run. Each user on the system have their crontab file and can run specific tasks whether they are logged in or not. 
  
Any user can read the file keeping system-wide cron jobs under `/etc/crontab`
	![[Pasted image 20240824004958.png]]
You can see the `backup.sh` script was configured to run every minute. The content of the file shows a simple script that creates a backup of the prices.xls file.
	![[Pasted image 20240824005024.png]]
As our current user can access this script, we can easily modify it to create a reverse shell, hopefully with root privileges.  The script will use the tools available on the target system to launch a reverse shell. Two points to note:
1. The command syntax will vary depending on the available tools. (e.g. `nc` will probably not support the `-e` option you may have seen used in other cases).
2. We should always prefer to start reverse shells, as we not want to compromise the system integrity during a real penetration testing engagement.
	![[Pasted image 20240824005130.png]]![[Pasted image 20240824005143.png]]
Crontab is always worth checking as it can sometimes lead to easy privilege escalation vectors. The following scenario is not uncommon in companies that do not have a certain cyber security maturity level:
1. System administrators need to run a script at regular intervals.
2. They create a cron job to do this
3. After a while, the script becomes useless, and they delete it  
4. They do not clean the relevant cron job

This change management issue leads to a potential exploit leveraging cron jobs.
	![[Pasted image 20240824005207.png]]
The example above shows a similar situation where the antivirus.sh script was deleted, but the cron job still exists.  If the full path of the script is not defined (as it was done for the backup.sh script), cron will refer to the paths listed under the PATH variable in the /etc/crontab file. In this case, we should be able to create a script named “antivirus.sh” under our user’s home folder and it should be run by the cron job.

*Note:*
	In the odd event you find an existing script or task attached to a cron job, it is always worth spending time to understand the function of the script and how any tool is used within the context. For example, `tar`, `7z`, `rsync`, etc., can be exploited using their wildcard feature.

Some utilities can be tricked into executing malicious commands if wildcards (`*`, `?`, etc.) are used without caution. Here's how this might happen with some common tools:
#### 1. **`tar` Exploitation**
- **Scenario**: A cron job uses `tar` to archive files in a directory.
- **Exploit**: If you can create files in that directory, you might create a file with a name like `--checkpoint-action=exec=sh shell.sh` and `shell.sh` containing the commands you want to execute. When `tar` processes this file, it will execute the commands in `shell.sh` as part of its operation.
- **Mitigation**: Always use `--` to indicate the end of command options in `tar` and sanitize input filenames.

	`echo "{malicious_code}" > shell.sh touch -- '--checkpoint-action=exec=sh shell.sh'`

#### 2. **`7z` Exploitation**
- **Scenario**: A cron job uses `7z` to compress files.
- **Exploit**: Similar to `tar`, if `7z` is used in a way that allows user-controlled filenames, you might trick it into executing arbitrary commands by injecting special filenames.
- **Mitigation**: Carefully handle filenames and avoid passing unsanitized input directly to `7z`.

#### 3. **`rsync` Exploitation**
- **Scenario**: A cron job uses `rsync` to synchronize files between directories or systems.
- **Exploit**: If you can control the files being synchronized, you might create a file named like `--rsh=command_to_run`. `rsync` might interpret this as an option rather than a filename, potentially allowing code execution.
- **Mitigation**: Use `--` to separate file names from options and validate inputs.

	`touch -- '--rsh=sh {malicious_script.sh}'`


## **Examples**
Q) How many user-defined cron jobs can you see on the target system?
	![[Pasted image 20240824011016.png]]
Q) What is the content of the flag5.txt file?
- navigating trough the crontabs we see dat test.py file is deleted so now we can create our own with reverse shell payload included and we need to set permission via chmod 777 (r/w/x)
	![[Pasted image 20240824011035.png]]![[Pasted image 20240824011831.png]]![[Pasted image 20240824012606.png]]

Q) What is Matt's password?
- /etc/passwd (matt row)
- /etc/shadow (matt row)
- unshadow passwd.txt shadow.txt > passwords.txt
- john the ripper for hash cracking :) :)